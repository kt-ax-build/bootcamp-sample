Directory structure:
└── bootcamp-sample/
    ├── README.md
    ├── AI_Agentic_BootCamp_테스트전략_개선.md
    ├── architecture.md
    ├── docker-compose-test.yml
    ├── docker-compose.yml
    ├── LICENSE
    ├── .cursorrules
    ├── backend/
    │   ├── Dockerfile
    │   ├── Dockerfile.test
    │   ├── gradlew
    │   ├── gradlew.bat
    │   ├── package.json
    │   ├── test_scenario_AI_Agentic_BootCamp.md
    │   ├── test_scenario_템플릿_개선.md
    │   ├── gradle/
    │   │   └── wrapper/
    │   │       ├── gradle-wrapper.jar
    │   │       └── gradle-wrapper.properties
    │   ├── postman/
    │   │   ├── Hackathon_API.postman_collection.json
    │   │   └── Hackathon_API.postman_environment.json
    │   └── src/
    │       ├── main/
    │       │   ├── java/
    │       │   │   └── com/
    │       │   │       └── kt/
    │       │   │           └── hackathon/
    │       │   │               └── be/
    │       │   │                   ├── HackathonBackendApplication.java
    │       │   │                   ├── application/
    │       │   │                   │   ├── controller/
    │       │   │                   │   │   └── HackathonController.java
    │       │   │                   │   ├── dto/
    │       │   │                   │   │   └── TeamMemberRequestDto.java
    │       │   │                   │   ├── model/
    │       │   │                   │   │   ├── HackathonApplication.java
    │       │   │                   │   │   ├── IdeaInfo.java
    │       │   │                   │   │   ├── Team.java
    │       │   │                   │   │   └── TeamMember.java
    │       │   │                   │   ├── repository/
    │       │   │                   │   │   ├── HackathonApplicationRepository.java
    │       │   │                   │   │   └── TeamRepository.java
    │       │   │                   │   └── service/
    │       │   │                   │       └── HackathonService.java
    │       │   │                   └── config/
    │       │   │                       ├── CorsConfig.java
    │       │   │                       └── SwaggerConfig.java
    │       │   └── resources/
    │       │       ├── application-prd.yml
    │       │       ├── application-test.yml
    │       │       ├── application.yml
    │       │       └── db/
    │       │           └── migration/
    │       │               └── common_sql/
    │       │                   ├── V1_1_001_1__create_teams_table.sql
    │       │                   ├── V1_1_002_1__create_team_members_table.sql
    │       │                   └── V1_1_003_1__create_hackathon_applications_table.sql
    │       └── test/
    │           └── java/
    │               └── com/
    │                   └── kt/
    │                       └── hackathon/
    │                           └── be/
    │                               └── HackathonServiceTest.java
    └── frontend/
        ├── README.md
        ├── cypress.config.js
        ├── Dockerfile
        ├── Dockerfile.test
        ├── eslint.config.js
        ├── frontend-test-scenarios.md
        ├── index.html
        ├── jest.config.js
        ├── nginx.conf
        ├── package.json
        ├── test-scenario-generation-prompt.md
        ├── tsconfig.app.json
        ├── tsconfig.json
        ├── tsconfig.node.json
        ├── vite.config.ts
        ├── .env.development
        ├── .env.production
        ├── .env.test
        ├── .prettierrc
        ├── cypress/
        │   ├── e2e/
        │   │   └── module-tests.cy.ts
        │   └── support/
        │       ├── commands.ts
        │       └── e2e.ts
        └── src/
            ├── App.tsx
            ├── main.tsx
            ├── setupTests.ts
            ├── vite-env.d.ts
            ├── __mocks__/
            │   └── envMock.ts
            ├── api/
            │   ├── axios.ts
            │   └── __tests__/
            │       └── axios.test.ts
            ├── components/
            │   ├── ConfirmationSection.tsx
            │   ├── IntroSection.tsx
            │   ├── Navigation.tsx
            │   ├── ParticipationSection.tsx
            │   ├── RegistrationSection.tsx
            │   └── __tests__/
            │       └── RegistrationSection.test.tsx
            ├── model/
            │   └── types.ts
            ├── services/
            │   ├── HackathonService.ts
            │   └── __tests__/
            │       └── HackathonService.test.ts
            ├── stores/
            │   ├── HackathonStore.ts
            │   └── __tests__/
            │       └── HackathonStore.test.ts
            └── theme/
                └── index.ts

================================================
FILE: README.md
================================================
# AI 해커톤 웹사이트

AI 해커톤 참가 신청 및 관리 시스템입니다. 팀 정보, 팀원 정보, 아이디어 정보를 관리하고 조회할 수 있는 웹 애플리케이션입니다.

## 🚀 기술 스택

### Frontend
- **React 18.3** - 사용자 인터페이스 라이브러리
- **TypeScript 5.6** - 타입 안전성을 위한 JavaScript 확장
- **Vite 6.0** - 빠른 개발 서버 및 빌드 도구
- **Material-UI 6.3** - React UI 컴포넌트 라이브러리
- **Axios 1.7** - HTTP 클라이언트
- **Zustand 5.0** - 상태 관리 라이브러리
- **React Router DOM 7.1** - 클라이언트 사이드 라우팅

### Backend
- **Java 17** - 프로그래밍 언어
- **Spring Boot 3.2.0** - Java 웹 프레임워크
- **Spring Data JPA** - 데이터 접근 계층
- **PostgreSQL** - 관계형 데이터베이스
- **Gradle** - 빌드 도구
- **Swagger/OpenAPI** - API 문서화

### Database
- **PostgreSQL 15** - Docker 컨테이너로 실행
- **pgAdmin** - 데이터베이스 관리 도구

## 📁 프로젝트 구조

```
bootCamp/
├── frontend/                 # React 프론트엔드
│   ├── src/
│   │   ├── api/             # API 설정
│   │   ├── components/       # 공통 컴포넌트
│   │   ├── model/           # 타입 정의
│   │   ├── services/        # API 서비스
│   │   └── ...
│   ├── package.json
│   └── ...
├── backend/                  # Spring Boot 백엔드
│   ├── src/main/java/
│   │   └── com/kt/hackathon/be/
│   │       ├── application/
│   │       │   ├── controller/    # REST API 컨트롤러
│   │       │   ├── service/       # 비즈니스 로직
│   │       │   ├── repository/    # 데이터 접근 계층
│   │       │   ├── model/         # 엔티티 클래스
│   │       │   └── dto/           # 데이터 전송 객체
│   │       └── config/            # 설정 클래스
│   ├── build.gradle
│   └── ...
├── docker-compose.yml        # Docker 컨테이너 설정
├── architecture.md           # 아키텍처 가이드
└── README.md                # 프로젝트 문서
```

## 🛠️ 설치 및 실행

### 사전 요구사항
- Node.js 18+ (프론트엔드)
- Java 17+ (백엔드)
- Docker & Docker Compose (데이터베이스)

### 1. 데이터베이스 실행
```bash
# PostgreSQL 및 pgAdmin 컨테이너 실행
docker-compose up -d

# 데이터베이스 상태 확인
docker ps
```

### 2. 백엔드 실행
```bash
cd backend

# 의존성 설치 및 빌드
./gradlew build

# 개발 서버 실행
./gradlew bootRun
```

백엔드 서버는 `http://localhost:8080`에서 실행됩니다.

### 3. 프론트엔드 실행
```bash
cd frontend

# 의존성 설치
npm install

# 개발 서버 실행
npm run dev
```

프론트엔드는 `http://localhost:5173`에서 실행됩니다.

## 🎯 주요 기능

### 1. 참가 신청
- **팀 정보 입력**: 팀명, 팀 구성, 팀 소개
- **팀원 정보 관리**: 팀 리더 및 추가 팀원 정보 입력
- **아이디어 정보**: 아이디어 제목, 설명, 문제 정의, 솔루션 접근 방법
- **기술 스택**: 사용 예정 기술 스택 입력

### 2. 신청 조회
- **팀명으로 조회**: 팀명을 입력하여 신청 정보 조회
- **이메일로 조회**: 신청자 이메일을 입력하여 신청 정보 조회
- **상세 정보 표시**: 팀 정보, 팀원 정보, 아이디어 정보, 신청 상태 표시

### 3. 관리 기능
- **신청 목록 조회**: 모든 신청 정보 조회
- **신청 상태 관리**: PENDING, APPROVED, REJECTED 상태 관리
- **신청 정보 수정**: 기존 신청 정보 수정
- **신청 삭제**: 신청 정보 삭제

## 📊 데이터베이스 스키마

### 주요 테이블
- **teams**: 팀 정보
- **team_members**: 팀원 정보
- **hackathon_applications**: 해커톤 신청 정보

### 관계
- `teams` ↔ `team_members`: 1:N 관계
- `teams` ↔ `hackathon_applications`: 1:1 관계

## 🔧 개발 가이드

### 프론트엔드 개발
```bash
cd frontend

# 개발 서버 실행
npm run dev

# 빌드
npm run build

# 테스트
npm run test

# 코드 포맷팅
npm run format
```

### 백엔드 개발
```bash
cd backend

# 개발 서버 실행
./gradlew bootRun

# 빌드
./gradlew build

# 테스트
./gradlew test

# 코드 포맷팅
./gradlew spotlessApply
```

### API 문서
- Swagger UI: `http://localhost:8080/swagger-ui.html`
- API 엔드포인트: `http://localhost:8080/api/hackathon/v1/`

## 🧪 테스트

### 프론트엔드 테스트
```bash
cd frontend
npm run test          # 단위 테스트
npm run test:watch    # 테스트 감시 모드
npm run test:coverage # 커버리지 리포트
npm run test:e2e      # E2E 테스트
```

### 백엔드 테스트
```bash
cd backend
./gradlew test        # 단위 테스트
./gradlew jacocoTestReport  # 커버리지 리포트
```

## 📝 API 명세

### 참가 신청 API
- `POST /api/hackathon/v1/applications` - 신청 생성
- `GET /api/hackathon/v1/applications` - 신청 목록 조회
- `GET /api/hackathon/v1/applications/{id}` - 신청 상세 조회
- `PUT /api/hackathon/v1/applications/{id}` - 신청 수정
- `DELETE /api/hackathon/v1/applications/{id}` - 신청 삭제

### 조회 파라미터
- `teamName`: 팀명으로 조회
- `memberName`: 팀원 이름 또는 이메일로 조회

## 🐳 Docker

### 데이터베이스 컨테이너
```bash
# 컨테이너 실행
docker-compose up -d

# 컨테이너 중지
docker-compose down

# 데이터베이스 접속
docker exec -it hackathon-postgres psql -U postgres -d hackathon_db
```

### pgAdmin 접속
- URL: `http://localhost:5050`
- Email: `admin@hackathon.com`
- Password: `hackathon123!`

## 📋 개발 규칙

### 브랜치 전략
- `feature/이슈번호-feature-이슈제목` 형식으로 브랜치 생성
- `develop` 브랜치에서 분기

### 코드 스타일
- **프론트엔드**: Prettier를 사용한 자동 포맷팅
- **백엔드**: Google Java Format을 사용한 자동 포맷팅

### 명명 규칙
- **변수/함수**: `camelCase`
- **컴포넌트**: `PascalCase`
- **상수**: `SNAKE_CASE`

## 🚨 문제 해결

### 일반적인 문제들

1. **데이터베이스 연결 오류**
   ```bash
   # 컨테이너 재시작
   docker-compose down
   docker-compose up -d
   ```

2. **포트 충돌**
   - 백엔드: 8080 포트 확인
   - 프론트엔드: 5173 포트 확인
   - PostgreSQL: 5432 포트 확인
   - pgAdmin: 5050 포트 확인

3. **빌드 오류**
   ```bash
   # 프론트엔드
   cd frontend
   rm -rf node_modules package-lock.json
   npm install

   # 백엔드
   cd backend
   ./gradlew clean build
   ```

## 📞 지원

프로젝트 관련 문의사항이 있으시면 다음으로 연락해주세요:
- 이메일: ai-hackathon@company.com

## 📄 라이선스

이 프로젝트는 내부 사용을 위한 프로젝트입니다. 


================================================
FILE: AI_Agentic_BootCamp_테스트전략_개선.md
================================================
# AI Agentic Boot Camp 테스트 전략 (교육 환경 특화)

## 📋 프로젝트 개요

### 프로젝트 정보
- **프로젝트명**: AI Agentic Boot Camp 교육과정 - 해커톤 신청 사이트
- **프로젝트 유형**: 웹/API 애플리케이션
- **개발 환경**: 로컬 환경 (교육용)
- **개발 기간**: 2일 (교육 기간)
- **팀 구성**: 교육생 1인 (개발 + 테스트 통합)

### 주요 기능
- 대회 소개 및 공지사항
- 참가 안내 및 FAQ
- 팀 신청 및 접수 (팀명 유니크 확인 포함)
- 파일 첨부/삭제 기능
- 신청 내역 확인/수정/삭제

## 🏗️ 기술 스택

### 프론트엔드
- **프레임워크**: React
- **테스트 도구**: Jest (단위 테스트), Cypress (E2E 테스트)

### 백엔드
- **프레임워크**: Spring Boot
- **데이터베이스**: PostgreSQL
- **테스트 도구**: JUnit 5, Mockito, Jacoco (커버리지 측정), Newman (API 테스트)

### 개발 프로세스
- **방법론**: 애자일
- **브랜치 전략**: feature, develop 브랜치 운영
- **코드 리뷰**: AI를 이용한 PR 리뷰 (테스트 코드 포함)
- **자동화**: Husky를 통한 커밋 전 테스트 수행

## 🎯 테스트 전략 목표 (교육 환경 특화)

### 품질 목표
- **백엔드 테스트 커버리지**: 70% 이상
- **API 응답 시간**: 1초 이내
- **동시 사용자 처리**: 10명
- **브라우저 호환성**: Chrome, Edge

### 테스트 피라미드 구조 (교육 환경)
```
    ┌─────────────┐
    │   E2E Test  │ ← Cypress (프론트엔드)
    └─────────────┘
    ┌─────────────┐
    │ API/Module  │ ← Newman (백엔드) + Cypress (프론트엔드)
    │    Test     │
    └─────────────┘
    ┌─────────────┐
    │  Unit Test  │ ← Jest (프론트엔드) + JUnit 5 (백엔드)
    └─────────────┘
```

## 📊 테스트 범위 및 전략 (교육 환경 특화)

### 1. 백엔드 테스트 전략

#### 1.1 단위 테스트 (Unit Test)
- **대상**: Service 계층 (HackathonService)
- **도구**: JUnit 5, Mockito
- **커버리지 목표**: 70% 이상
- **테스트 격리**: @Transactional, @Rollback 활용
- **Mock 전략**: Repository 계층 Mock으로 외부 의존성 격리

#### 1.2 API 테스트 (API Test)
- **대상**: 백엔드 API 통합 테스트
- **도구**: Newman (Postman Collection)
- **테스트 범위**: HTTP 상태 코드, 응답 데이터 형식, 전체 플로우 검증

### 2. 프론트엔드 테스트 전략

#### 2.1 단위 테스트 (Unit Test)
- **대상**: React 컴포넌트, 유틸리티 함수
- **도구**: Jest
- **테스트 범위**: Props/State에 따른 렌더링, 사용자 인터랙션, API 연동 로직

#### 2.2 E2E 테스트 (End-to-End Test)
- **대상**: 사용자 시나리오 기반 테스트
- **도구**: Cypress
- **테스트 범위**: 페이지 네비게이션, 폼 입력/제출, 데이터 표시, 오류 처리

### 3. 교육 환경 특화 전략

#### 3.1 테스트 우선순위
1. **백엔드 핵심 CRUD 기능**: 생성, 조회, 수정, 삭제
2. **단위 테스트 집중**: Service 계층 비즈니스 로직
3. **API 테스트 보완**: 백엔드 API 통합 검증
4. **성능/보안 제외**: 교육 시간 제약 고려

#### 3.2 프론트엔드 테스트 계획
1. **React 컴포넌트 테스트**: Jest를 활용한 단위 테스트
2. **모듈 테스트**: Cypress를 활용한 API 모킹 처리
3. **E2E 테스트**: Cypress를 활용한 사용자 시나리오

#### 3.3 백엔드 테스트 데이터 전략
- **타임스탬프 기반**: 유니크 값 생성으로 데이터 격리
- **Mock 객체 활용**: Repository 계층 Mock으로 외부 의존성 격리
- **트랜잭션 격리**: @Transactional, @Rollback으로 테스트 격리

#### 3.4 백엔드 테스트 실행 전략
- **단위 테스트**: JUnit 5 + Mockito로 빠른 피드백
- **API 테스트**: Newman으로 백엔드 API 검증
- **자동화**: Gradle 테스트 태스크로 CI/CD 파이프라인 구축

#### 3.5 프론트엔드 테스트 전략
- **단위 테스트**: Jest + React Testing Library
- **모듈 테스트**: Cypress Intercept로 API 모킹 및 서비스 계층 검증
- **E2E 테스트**: Cypress로 사용자 시나리오 검증

## 🔧 테스트 자동화 전략 (교육 환경)

### 1. CI/CD 파이프라인
- **환경**: 로컬 환경
- **자동화 도구**: Gradle
- **실행 시점**: 빌드 시 자동 테스트 수행
- **검증 항목**: 단위 테스트, API 테스트

### 2. 백엔드 테스트 실행 순서
1. **백엔드 단위 테스트** (JUnit 5)
2. **API 테스트** (Newman)

### 3. 전체 시스템 테스트 순서
1. **백엔드 단위 테스트** (JUnit 5)
2. **API/Module 테스트** (Newman + Cypress)
3. **프론트엔드 단위 테스트** (Jest)
4. **E2E 테스트** (Cypress)

### 3. 품질 게이트
- **테스트 커버리지**: 70% 이상 통과
- **테스트 실패**: 빌드 중단
- **코드 리뷰**: AI를 통한 테스트 코드 검증

## 📋 테스트 관리 전략 (교육 환경)

### 1. 이슈 관리
- **도구**: 로컬 문서 관리
- **버그 리포트**: 체계적 버그 관리
- **이슈 추적**: 기능별 이슈 분류 및 우선순위 설정

### 2. 문서화
- **테스트 시나리오**: 템플릿 기반 체계적 작성
- **테스트 결과**: 실행 결과 및 커버리지 리포트 관리
- **지식 공유**: AI를 통한 테스트 코드 리뷰 및 개선

### 3. 품질 측정
- **커버리지 측정**: Jacoco를 통한 백엔드 커버리지 측정
- **성능 측정**: API 응답 시간 모니터링
- **품질 지표**: 테스트 통과율, 커버리지, 버그 발견율

## 🎯 핵심 테스트 시나리오 영역 (교육 환경)

### 1. 백엔드 테스트 영역
- **API 기능 테스트**: RESTful API 엔드포인트 검증
- **비즈니스 로직 테스트**: 서비스 계층 핵심 로직 검증
- **데이터 처리 테스트**: 데이터베이스 연동 및 CRUD 기능 검증

### 2. 프론트엔드 테스트 영역
- **사용자 인터페이스 테스트**: 컴포넌트 렌더링 및 상호작용 검증
- **폼 처리 테스트**: 입력 유효성 검증 및 오류 처리 검증
- **API 연동 테스트**: 백엔드 API와의 통신 검증

### 3. API/Module Test 영역

#### API Test (백엔드)
- **대상**: 백엔드 RESTful API 엔드포인트
- **도구**: Newman (Postman Collection)
- **테스트 범위**: 
  - HTTP 상태 코드 검증
  - 응답 데이터 형식 검증
  - 전체 API 플로우 검증
  - 에러 상황 처리

#### Module Test (프론트엔드)
- **대상**: 프론트엔드 서비스 계층 및 API 호출 로직
- **도구**: Cypress Intercept
- **테스트 범위**:
  - HackathonService 메서드 동작 검증
  - API 호출 성공/실패 시나리오
  - 응답 데이터 처리 로직
  - 에러 핸들링 및 상태 관리
  - 로딩 상태 처리
- **테스트 범위**:
  - HackathonService 메서드 동작 검증
  - API 호출 성공/실패 시나리오
  - 응답 데이터 처리 로직
  - 에러 핸들링 및 상태 관리
  - 로딩 상태 처리

## ⚠️ 리스크 관리 (교육 환경)

### 1. 교육 환경 특성 고려사항
- **제한된 시간**: 2일 교육 기간 내 완료
- **단일 개발자**: 개발과 테스트 병행 수행
- **로컬 환경**: 실제 운영 환경과의 차이점 인지

### 2. 대응 전략
- **우선순위 기반**: 핵심 기능 우선 테스트
- **자동화 활용**: 반복 작업 자동화로 시간 절약
- **AI 도구 활용**: 테스트 코드 생성 및 리뷰 지원

## 📈 성공 지표 (교육 환경)

### 1. 백엔드 품질 지표
- 백엔드 테스트 커버리지 70% 이상 달성
- 모든 핵심 API 기능에 대한 테스트 케이스 작성
- 주요 백엔드 시나리오 API 테스트 완료

### 2. 전체 시스템 품질 지표
- 모든 핵심 기능에 대한 E2E 테스트 케이스 작성
- 주요 사용자 시나리오 전체 플로우 테스트 완료

### 3. 프로세스 지표
- 테스트 자동화 파이프라인 구축 완료
- 체계적인 버그 관리 시스템 운영
- AI를 활용한 테스트 코드 품질 향상

## 🔄 지속적 개선 (교육 환경)

### 1. 테스트 전략 개선
- 테스트 실행 결과 분석
- 커버리지 미달 영역 보완
- 새로운 기능에 대한 테스트 케이스 추가

### 2. 도구 및 프로세스 개선
- AI 도구 활용도 향상
- 테스트 자동화 범위 확대
- 테스트 실행 시간 최적화

---

## 📝 참고사항 (교육 환경)

- 이 테스트 전략은 교육 환경 특성을 고려하여 작성되었습니다.
- 실제 운영 환경과는 차이가 있을 수 있으므로, 필요시 전략을 조정하세요.
- AI 도구를 적극 활용하여 테스트 효율성을 높이세요.
- 테스트 시나리오는 별도 문서로 작성하여 관리하세요.
- 교육 시간 제약을 고려하여 핵심 기능에 집중하세요. 


================================================
FILE: architecture.md
================================================
[Binary file]


================================================
FILE: docker-compose-test.yml
================================================
version: '3.8'

services:
  be-local:
    build:
      context: ./backend
      dockerfile: Dockerfile.test
    container_name: be-local
    environment:
      - JDK_JAVA_OPTIONS='-Dspring.profiles.active=test'
    ports:
      - "8080:8080"
    restart: unless-stopped

  fe-local:
    build:
      context: ./frontend
      dockerfile: Dockerfile.test
    container_name: fe-local
    ports:
      - "5173:8080"
    depends_on:
      - be-local
    restart: unless-stopped


================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: hackathon-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: hackathon_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: hackathon_pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@hackathon.com
      PGADMIN_DEFAULT_PASSWORD: hackathon123!
    ports:
      - "5050:80"
    depends_on:
      - postgres
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local 


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 kt-ax-build

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: .cursorrules
================================================
당신은 10년 경력의 시니어 풀스택 개발자입니다.

당신은 프로젝트의 전체적인 구조를 이해하고 있으며, 각 파일의 역할을 이해하고 있습니다.

프로젝트 정보 및 개발에 필요한 정보는 현재 폴더에 있는 architecture.md 파일을 참고 하여 개발을 진행합니다.

프로젝트 구조는 다음과 같습니다.
- frontend
- backend

frontend 는 frontend 폴더를 만들어서 진행합니다.
backend 는 backend 폴더를 만들어서 진행합니다.

use context7










================================================
FILE: backend/Dockerfile
================================================
FROM gradle:8.10.2-jdk17-focal AS build
WORKDIR /build

COPY build.gradle settings.gradle /build/
COPY src ./src

RUN gradle build -x test --build-cache
RUN ls -al /build/build/libs/

FROM mcr.microsoft.com/openjdk/jdk:17-mariner
COPY --from=build /build/build/libs/bootcamp-sample-be-0.0.1-SNAPSHOT.jar /app/bin/app.jar

CMD ["java", "-jar", "/app/bin/app.jar"]



================================================
FILE: backend/Dockerfile.test
================================================
FROM gradle:8.10.2-jdk17-focal AS build
WORKDIR /build

COPY build.gradle settings.gradle /build/
COPY src ./src

RUN gradle build -x test --build-cache
RUN ls -al /build/build/libs/

FROM mcr.microsoft.com/openjdk/jdk:17-mariner
COPY --from=build /build/build/libs/bootcamp-sample-be-0.0.1-SNAPSHOT.jar /app/bin/app.jar

CMD ["java", "-jar", "/app/bin/app.jar"]



================================================
FILE: backend/gradlew
================================================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"



================================================
FILE: backend/gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: backend/package.json
================================================
{
  "name": "hackathon-backend",
  "version": "1.0.0",
  "description": "AI Agentic Boot Camp Backend API Tests",
  "scripts": {
    "test:api": "newman run postman/Hackathon_API.postman_collection.json -e postman/Hackathon_API.postman_environment.json -r cli,json",
    "test:api:cli": "newman run postman/Hackathon_API.postman_collection.json -e postman/Hackathon_API.postman_environment.json -r cli",
    "test:api:json": "newman run postman/Hackathon_API.postman_collection.json -e postman/Hackathon_API.postman_environment.json -r json",
    "install:newman": "npm install -g newman",
    "postman:setup": "mkdir -p postman api-tests/newman-reports"
  },
  "devDependencies": {
    "newman": "^6.2.1",
    "newman-reporter-json": "^1.0.0"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "keywords": [
    "api-testing",
    "newman",
    "postman",
    "hackathon"
  ],
  "author": "AI Agentic Boot Camp",
  "license": "MIT"
}



================================================
FILE: backend/test_scenario_AI_Agentic_BootCamp.md
================================================
# AI Agentic Boot Camp 테스트 시나리오 (교육 환경 특화)

## 📋 테스트 시나리오 템플릿 (교육용)

### 1. 백엔드 테스트 시나리오

#### 1.1 단위 테스트 (Unit Test) - HackathonService

##### 해커톤 애플리케이션 생성 테스트
- **[TC-BE-001] 새로운 팀으로 해커톤 애플리케이션 생성**
  - **입력**: TeamMemberRequestDto (teamName: "테스트팀", ideaTitle: "AI 챗봇", ideaDescription: "AI 기반 고객 서비스 챗봇")
  - **예상 결과**: HackathonApplication 객체 반환 (status: PENDING, 팀 정보 포함)
  - **검증**: 반환된 객체의 팀명과 아이디어 제목 검증

- **[TC-BE-002] 기존 팀으로 해커톤 애플리케이션 생성**
  - **입력**: TeamMemberRequestDto (teamName: "기존팀", ideaTitle: "블록체인 서비스", ideaDescription: "분산형 블록체인 플랫폼")
  - **예상 결과**: HackathonApplication 객체 반환 (기존 팀 정보 사용)
  - **검증**: 새로운 팀 생성하지 않고 기존 팀 정보 사용 확인

##### 해커톤 애플리케이션 조회 테스트
- **[TC-BE-003] 팀명으로 애플리케이션 조회**
  - **입력**: teamName: "테스트팀", memberName: null
  - **예상 결과**: List<HackathonApplication> 반환 (해당 팀의 애플리케이션 목록)
  - **검증**: 반환된 리스트 크기 및 내용 검증

- **[TC-BE-004] 멤버명으로 애플리케이션 조회**
  - **입력**: teamName: null, memberName: "김개발"
  - **예상 결과**: List<HackathonApplication> 반환 (해당 멤버가 속한 팀의 애플리케이션 목록)
  - **검증**: 반환된 리스트 검증

- **[TC-BE-005] 전체 애플리케이션 조회**
  - **입력**: teamName: null, memberName: null
  - **예상 결과**: List<HackathonApplication> 반환 (전체 애플리케이션 목록)
  - **검증**: 반환된 리스트 검증

- **[TC-BE-006] 조회 중 예외 발생 처리**
  - **입력**: teamName: "테스트팀", memberName: null
  - **예상 결과**: 빈 리스트 반환 (예외 발생 시)
  - **검증**: 예외 발생 시 빈 리스트 반환 확인

##### 해커톤 애플리케이션 상세 조회 테스트
- **[TC-BE-007] 존재하는 애플리케이션 상세 조회**
  - **입력**: id: 1L
  - **예상 결과**: HackathonApplication 객체 반환
  - **검증**: 반환된 객체의 ID 검증

- **[TC-BE-008] 존재하지 않는 애플리케이션 상세 조회**
  - **입력**: id: 999L
  - **예상 결과**: RuntimeException 발생 ("Application not found with id: 999")
  - **검증**: 예외 메시지 검증

##### 해커톤 애플리케이션 수정 테스트
- **[TC-BE-009] 애플리케이션 정보 수정**
  - **입력**: id: 1L, TeamMemberRequestDto (ideaTitle: "수정된 아이디어", ideaDescription: "수정된 설명")
  - **예상 결과**: 수정된 HackathonApplication 객체 반환
  - **검증**: 아이디어 제목과 설명 수정 확인

- **[TC-BE-010] 팀명 변경으로 애플리케이션 수정**
  - **입력**: id: 1L, TeamMemberRequestDto (teamName: "새로운팀명")
  - **예상 결과**: 팀 정보가 변경된 HackathonApplication 객체 반환
  - **검증**: 팀 정보 변경 확인

- **[TC-BE-011] 존재하지 않는 애플리케이션 수정**
  - **입력**: id: 999L, TeamMemberRequestDto (ideaTitle: "수정된 아이디어")
  - **예상 결과**: RuntimeException 발생 ("Application not found with id: 999")
  - **검증**: 예외 메시지 검증

##### 해커톤 애플리케이션 삭제 테스트
- **[TC-BE-012] 애플리케이션 삭제**
  - **입력**: id: 1L
  - **예상 결과**: void 반환 (삭제 성공)
  - **검증**: 삭제 성공 확인

#### 1.2 API 테스트 (Newman) - HackathonController

##### POST /api/hackathon/v1/applications (해커톤 애플리케이션 생성)
- **[TC-API-001] 정상적인 해커톤 애플리케이션 생성**
  - **요청**: POST /api/hackathon/v1/applications
  - **예상 응답**: HTTP 200 OK
  - **검증**: HTTP 상태 코드 200, 응답 데이터에 팀명과 아이디어 정보 포함, status가 PENDING인지 확인

- **[TC-API-002] 필수 정보 누락으로 애플리케이션 생성 실패**
  - **요청**: POST /api/hackathon/v1/applications (teamName: "", ideaTitle: "", ideaDescription: "", members: [빈 팀원 정보])
  - **예상 응답**: HTTP 500 Internal Server Error 또는 HTTP 200 OK (테이블 초기화 상태 고려)
  - **검증**: HTTP 상태 코드 500 또는 200, 응답 데이터 검증

##### GET /api/hackathon/v1/applications (해커톤 애플리케이션 조회)
- **[TC-API-003] 팀명으로 애플리케이션 조회**
  - **요청**: GET /api/hackathon/v1/applications?teamName=AI개발팀
  - **예상 응답**: HTTP 200 OK
  - **검증**: HTTP 상태 코드 200, 배열 형태 응답, 해당 팀의 애플리케이션만 포함

- **[TC-API-004] 멤버명으로 애플리케이션 조회**
  - **요청**: GET /api/hackathon/v1/applications?memberName=김개발
  - **예상 응답**: HTTP 200 OK
  - **검증**: HTTP 상태 코드 200, 해당 멤버가 속한 팀의 애플리케이션만 포함

- **[TC-API-005] 전체 애플리케이션 조회**
  - **요청**: GET /api/hackathon/v1/applications
  - **예상 응답**: HTTP 200 OK 또는 500 Internal Server Error
  - **검증**: HTTP 상태 코드 200 또는 500, 응답이 배열이거나 에러 메시지 포함

##### GET /api/hackathon/v1/applications/{id} (해커톤 애플리케이션 상세 조회)
- **[TC-API-006] 존재하는 애플리케이션 상세 조회**
  - **요청**: GET /api/hackathon/v1/applications/1
  - **예상 응답**: HTTP 200 OK
  - **검증**: HTTP 상태 코드 200, 특정 ID의 애플리케이션 상세 정보 포함

- **[TC-API-007] 존재하지 않는 애플리케이션 상세 조회**
  - **요청**: GET /api/hackathon/v1/applications/999
  - **예상 응답**: HTTP 404 Not Found 또는 500 Internal Server Error
  - **검증**: HTTP 상태 코드 404 또는 500, 에러 응답 확인

##### PUT /api/hackathon/v1/applications/{id} (해커톤 애플리케이션 수정)
- **[TC-API-008] 애플리케이션 정보 수정**
  - **요청**: PUT /api/hackathon/v1/applications/1
  - **예상 응답**: HTTP 200 OK
  - **검증**: HTTP 상태 코드 200, 수정된 아이디어 제목과 설명 확인

##### DELETE /api/hackathon/v1/applications/{id} (해커톤 애플리케이션 삭제)
- **[TC-API-009] 존재하는 애플리케이션 삭제**
  - **요청**: DELETE /api/hackathon/v1/applications/1
  - **예상 응답**: HTTP 204 No Content
  - **검증**: HTTP 상태 코드 204, 응답 본문 없음

### 2. 교육 환경 특화 가이드

#### 2.1 테스트 우선순위
1. **핵심 기능 우선**: CRUD 기능 중심 (생성, 조회, 수정, 삭제)
2. **단위 테스트 집중**: HackathonService 계층 70% 커버리지
3. **API 테스트 보완**: 전체 플로우 검증
4. **성능/보안 제외**: 교육 시간 제약 고려

#### 2.2 테스트 데이터 전략
- **타임스탬프 기반**: 유니크 값 생성으로 데이터 격리
- **Mock 객체 활용**: Repository 계층 Mock으로 외부 의존성 격리
- **트랜잭션 격리**: @Transactional, @Rollback 활용

#### 2.3 테스트 실행 전략
- **단위 테스트**: JUnit 5 + Mockito
- **API 테스트**: Newman (Postman Collection)
- **자동화**: Gradle 테스트 태스크

---

## 📝 사용 가이드 (교육 환경 특화)

### 템플릿 사용 방법:
1. **[프로젝트명]** 부분을 "AI Agentic Boot Camp"로 변경
2. **[서비스명]**, **[컨트롤러명]** 부분을 "HackathonService", "HackathonController"로 변경
3. **[기능명]** 부분을 실제 기능명으로 변경 (생성, 조회, 수정, 삭제)
4. **[테스트 케이스명]** 부분을 구체적인 테스트 케이스명으로 변경
5. **[입력 데이터 설명]**, **[예상 결과 설명]**, **[검증 항목 설명]** 부분을 실제 소스 코드 기반으로 구체적으로 작성
6. **[HTTP_METHOD]**, **[API_PATH]** 부분을 실제 API 정보로 변경

### 테스트 케이스 ID 규칙 (교육 환경):
- **TC-BE-XXX**: 백엔드 단위 테스트 (BE = Backend)
- **TC-API-XXX**: API 테스트 (API = Newman/Postman)

### 테스트 케이스 작성 가이드 (교육 환경):

#### 백엔드 테스트
- **실제 소스 코드 기반**: HackathonService의 실제 메서드와 파라미터 반영
- **구체적인 검증 항목**: Mock 객체 동작과 반환값 명시
- **교육 시간 고려**: 핵심 기능 우선, 복잡한 시나리오 제외

#### API 테스트
- **전체 시스템 검증**: 실제 HTTP 통신 기반
- **실제 데이터 기반**: 실제 JSON 요청/응답 형식
- **교육 환경 특성**: 성능/보안 테스트 제외

### 검증 항목 작성 가이드 (교육 환경):

#### 백엔드 검증
- Mock 객체 메서드 호출 확인 (TeamRepository, HackathonApplicationRepository)
- 반환값 타입 및 내용 확인 (HackathonApplication, List<HackathonApplication>)
- 예외 처리 동작 확인 (RuntimeException)
- 비즈니스 로직 동작 확인 (팀 생성/조회, 애플리케이션 CRUD)

#### API 검증
- HTTP 상태 코드 확인 (200, 204, 500)
- 응답 데이터 형식 및 내용 확인 (JSON 구조)
- 전체 플로우 데이터 일관성 확인

### 교육 환경 특화 전략:
- **테스트 피라미드 구조** 준수 (단위 > API)
- **실제 소스 코드 기반** 테스트 케이스 작성
- **테스트 커버리지 목표** 설정 (백엔드 70% 이상)
- **테스트 격리 전략** 적용 (@Transactional, Mock 객체 활용)
- **교육 시간 제약** 고려 (핵심 기능 우선) 


================================================
FILE: backend/test_scenario_템플릿_개선.md
================================================
[Binary file]


================================================
FILE: backend/gradle/wrapper/gradle-wrapper.jar
================================================
[Binary file]


================================================
FILE: backend/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



================================================
FILE: backend/postman/Hackathon_API.postman_collection.json
================================================
{
  "info": {
    "name": "Hackathon API Collection",
    "description": "AI Agentic Boot Camp 해커톤 API 테스트 컬렉션",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "해커톤 애플리케이션 생성",
      "item": [
        {
          "name": "TC-API-001: 정상적인 해커톤 애플리케이션 생성",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"teamName\": \"{{dynamicTeamName}}\",\n  \"memberName\": \"{{dynamicMemberName}}\",\n  \"email\": \"{{dynamicEmail}}\",\n  \"phone\": \"{{dynamicPhone}}\",\n  \"role\": \"개발자\",\n  \"ideaTitle\": \"AI 챗봇 서비스\",\n  \"ideaDescription\": \"고객 서비스를 위한 AI 챗봇 개발\",\n  \"department\": \"개발팀\",\n  \"position\": \"시니어 개발자\",\n  \"isLeader\": true\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications",
              "host": ["localhost"],
              "port": "8080",
              "path": ["api", "hackathon", "v1", "applications"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// 동적 팀명 생성 (타임스탬프 기반)",
                  "const timestamp = new Date().getTime();",
                  "const dynamicTeamName = `테스트팀_${timestamp}`;",
                  "const dynamicMemberName = `테스트멤버_${timestamp}`;",
                  "const dynamicEmail = `test_${timestamp}@example.com`;",
                  "const dynamicPhone = `010-${String(timestamp).slice(-8)}`;",
                  "",
                  "// 환경 변수에 저장",
                  "pm.environment.set('dynamicTeamName', dynamicTeamName);",
                  "pm.environment.set('dynamicMemberName', dynamicMemberName);",
                  "pm.environment.set('dynamicEmail', dynamicEmail);",
                  "pm.environment.set('dynamicPhone', dynamicPhone);",
                  "",
                  "console.log('생성된 팀명:', dynamicTeamName);",
                  "console.log('생성된 멤버명:', dynamicMemberName);"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"응답 데이터에 아이디어 정보 포함\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson.ideaTitle).to.eql(\"AI 챗봇 서비스\");",
                  "    pm.expect(responseJson.ideaDescription).to.eql(\"고객 서비스를 위한 AI 챗봇 개발\");",
                  "});",
                  "",
                  "pm.test(\"status가 PENDING인지 확인\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson.status).to.eql(\"PENDING\");",
                  "});",
                  "",
                  "pm.test(\"ID가 생성되었는지 확인\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson).to.have.property('id');",
                  "    pm.expect(responseJson.id).to.be.a('number');",
                  "});",
                  "",
                  "// 생성된 애플리케이션 ID 저장",
                  "if (pm.response.code === 200) {",
                  "    const responseJson = pm.response.json();",
                  "    pm.environment.set(\"createdApplicationId\", responseJson.id);",
                  "    console.log(\"생성된 애플리케이션 ID:\", responseJson.id);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "TC-API-002: 필수 정보 누락으로 애플리케이션 생성 실패",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"teamName\": \"\",\n  \"ideaTitle\": \"\",\n  \"ideaDescription\": \"\",\n  \"members\": [{\n    \"name\": \"\",\n    \"email\": \"\",\n    \"phone\": \"\",\n    \"role\": \"\",\n    \"department\": \"\",\n    \"position\": \"\",\n    \"isLeader\": false\n  }]\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 500 또는 200\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 500]);",
                  "});",
                  "",
                  "pm.test(\"응답 확인\", function () {",
                  "    if (pm.response.code === 500) {",
                  "        const responseJson = pm.response.json();",
                  "        pm.expect(responseJson).to.have.property('error');",
                  "    } else if (pm.response.code === 200) {",
                  "        // 테이블이 초기화된 상태에서 빈 데이터로도 성공할 수 있음",
                  "        const responseJson = pm.response.json();",
                  "        pm.expect(responseJson).to.have.property('id');",
                  "    }",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "해커톤 애플리케이션 조회",
      "item": [
        {
          "name": "TC-API-003: 팀명으로 애플리케이션 조회",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications?teamName={{dynamicTeamName}}",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications"],
              "query": [
                {
                  "key": "teamName",
                  "value": "{{dynamicTeamName}}"
                }
              ]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"배열 형태 응답\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson).to.be.an('array');",
                  "});",
                  "",
                  "pm.test(\"해당 팀의 애플리케이션만 포함\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson).to.be.an('array');",
                  "    if (responseJson.length > 0) {",
                  "        pm.expect(responseJson[0]).to.have.property('id');",
                  "        pm.expect(responseJson[0]).to.have.property('ideaTitle');",
                  "    }",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "TC-API-004: 멤버명으로 애플리케이션 조회",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications?memberName={{dynamicMemberName}}",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications"],
              "query": [
                {
                  "key": "memberName",
                  "value": "{{dynamicMemberName}}"
                }
              ]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"해당 멤버가 속한 팀의 애플리케이션만 포함\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson).to.be.an('array');",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "TC-API-005: 전체 애플리케이션 조회",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200 또는 500\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 500]);",
                  "});",
                  "",
                  "pm.test(\"응답이 배열이거나 에러인지 확인\", function () {",
                  "    if (pm.response.code === 200) {",
                  "        const responseJson = pm.response.json();",
                  "        pm.expect(responseJson).to.be.an('array');",
                  "    } else {",
                  "        // 500 에러인 경우 빈 응답이거나 에러 메시지가 있을 수 있음",
                  "        pm.expect(pm.response.text()).to.not.be.undefined;",
                  "    }",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "해커톤 애플리케이션 상세 조회",
      "item": [
        {
          "name": "TC-API-006: 존재하는 애플리케이션 상세 조회",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications/{{createdApplicationId}}",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications", "{{createdApplicationId}}"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"특정 ID의 애플리케이션 상세 정보 포함\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson).to.have.property('id');",
                  "    pm.expect(responseJson).to.have.property('ideaTitle');",
                  "    pm.expect(responseJson).to.have.property('ideaDescription');",
                  "    pm.expect(responseJson).to.have.property('status');",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "TC-API-007: 존재하지 않는 애플리케이션 상세 조회",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications/999",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications", "999"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 404 또는 500\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([404, 500]);",
                  "});",
                  "",
                  "pm.test(\"에러 응답 확인\", function () {",
                  "    if (pm.response.code === 404) {",
                  "        // 404 Not Found인 경우 빈 응답이거나 에러 메시지가 있을 수 있음",
                  "        pm.expect(pm.response.text()).to.not.be.undefined;",
                  "    } else if (pm.response.code === 500) {",
                  "        // 500 에러인 경우 에러 메시지가 포함되어야 함",
                  "        try {",
                  "            const responseJson = pm.response.json();",
                  "            pm.expect(responseJson).to.have.property('error');",
                  "        } catch (e) {",
                  "            // JSON 파싱 실패 시에도 테스트 통과",
                  "            pm.expect(pm.response.text()).to.not.be.undefined;",
                  "        }",
                  "    }",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "해커톤 애플리케이션 수정",
      "item": [
        {
          "name": "TC-API-008: 애플리케이션 정보 수정",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"teamName\": \"{{dynamicTeamName}}\",\n  \"ideaTitle\": \"수정된 AI 챗봇 서비스\",\n  \"ideaDescription\": \"수정된 고객 서비스를 위한 AI 챗봇 개발\"\n}"
            },
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications/{{createdApplicationId}}",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications", "{{createdApplicationId}}"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"수정된 아이디어 제목과 설명 확인\", function () {",
                  "    const responseJson = pm.response.json();",
                  "    pm.expect(responseJson.ideaTitle).to.eql(\"수정된 AI 챗봇 서비스\");",
                  "    pm.expect(responseJson.ideaDescription).to.eql(\"수정된 고객 서비스를 위한 AI 챗봇 개발\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "해커톤 애플리케이션 삭제",
      "item": [
        {
          "name": "TC-API-009: 존재하는 애플리케이션 삭제",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "http://localhost:8080/api/hackathon/v1/applications/{{createdApplicationId}}",
              "host": ["http://localhost:8080"],
              "path": ["api", "hackathon", "v1", "applications", "{{createdApplicationId}}"]
            }
          },
          "response": [],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"HTTP 상태 코드 204\", function () {",
                  "    pm.response.to.have.status(204);",
                  "});",
                  "",
                  "pm.test(\"응답 본문 없음\", function () {",
                  "    pm.expect(pm.response.text()).to.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          ""
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          ""
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:8080"
    }
  ]
} 


================================================
FILE: backend/postman/Hackathon_API.postman_environment.json
================================================
{
  "id": "hackathon-api-environment",
  "name": "Hackathon API Environment",
  "values": [
    {
      "key": "baseUrl",
      "value": "http://localhost:8080",
      "type": "default",
      "enabled": true
    },
    {
      "key": "apiVersion",
      "value": "v1",
      "type": "default",
      "enabled": true
    },
    {
      "key": "contentType",
      "value": "application/json",
      "type": "default",
      "enabled": true
    },
    {
      "key": "createdApplicationId",
      "value": "",
      "type": "default",
      "enabled": true
    },
    {
      "key": "testTeamName",
      "value": "AI개발팀",
      "type": "default",
      "enabled": true
    },
    {
      "key": "testMemberName",
      "value": "김개발",
      "type": "default",
      "enabled": true
    },
    {
      "key": "testIdeaTitle",
      "value": "AI 챗봇 서비스",
      "type": "default",
      "enabled": true
    },
    {
      "key": "testIdeaDescription",
      "value": "고객 서비스를 위한 AI 챗봇 개발",
      "type": "default",
      "enabled": true
    }
  ],
  "_postman_variable_scope": "environment",
  "_postman_exported_at": "2024-01-01T00:00:00.000Z",
  "_postman_exported_using": "Postman/10.0.0"
} 


================================================
FILE: backend/src/main/java/com/kt/hackathon/be/HackathonBackendApplication.java
================================================
package com.kt.hackathon.be;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HackathonBackendApplication {

  public static void main(String[] args) {
    SpringApplication.run(HackathonBackendApplication.class, args);
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/controller/HackathonController.java
================================================
package com.kt.hackathon.be.application.controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.kt.hackathon.be.application.dto.TeamMemberRequestDto;
import com.kt.hackathon.be.application.model.HackathonApplication;
import com.kt.hackathon.be.application.service.HackathonService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/hackathon/v1")
@RequiredArgsConstructor
@Tag(name = "Hackathon", description = "해커톤 애플리케이션 관리 API")
public class HackathonController {

  private final HackathonService hackathonService;

  @PostMapping("/applications")
  @Operation(summary = "해커톤 애플리케이션 생성", description = "새로운 해커톤 애플리케이션을 생성합니다.")
  public ResponseEntity<?> createApplication(@RequestBody TeamMemberRequestDto request) {
    try {
      HackathonApplication application = hackathonService.createApplication(request);
      return ResponseEntity.ok(application);
    } catch (Exception e) {
      return ResponseEntity.status(500)
          .body(Map.of("error", e.getMessage(), "details", e.toString()));
    }
  }

  @GetMapping("/applications")
  @Operation(summary = "해커톤 애플리케이션 조회", description = "해커톤 애플리케이션 목록을 조회합니다.")
  public ResponseEntity<List<HackathonApplication>> getApplications(
      @RequestParam(required = false) String teamName,
      @RequestParam(required = false) String memberName) {
    try {
      List<HackathonApplication> applications =
          hackathonService.getApplications(teamName, memberName);
      return ResponseEntity.ok(applications);
    } catch (Exception e) {
      System.err.println("Error in getApplications: " + e.getMessage());
      e.printStackTrace();
      return ResponseEntity.status(500).build();
    }
  }

  @GetMapping("/applications/{id}")
  @Operation(summary = "해커톤 애플리케이션 상세 조회", description = "특정 해커톤 애플리케이션을 조회합니다.")
  public ResponseEntity<HackathonApplication> getApplication(@PathVariable Long id) {
    try {
      HackathonApplication application = hackathonService.getApplication(id);
      return ResponseEntity.ok(application);
    } catch (Exception e) {
      return ResponseEntity.notFound().build();
    }
  }

  @PutMapping("/applications/{id}")
  @Operation(summary = "해커톤 애플리케이션 수정", description = "해커톤 애플리케이션을 수정합니다.")
  public ResponseEntity<HackathonApplication> updateApplication(
      @PathVariable Long id, @RequestBody TeamMemberRequestDto request) {
    try {
      HackathonApplication application = hackathonService.updateApplication(id, request);
      return ResponseEntity.ok(application);
    } catch (Exception e) {
      return ResponseEntity.status(500).build();
    }
  }

  @DeleteMapping("/applications/{id}")
  @Operation(summary = "해커톤 애플리케이션 삭제", description = "해커톤 애플리케이션을 삭제합니다.")
  public ResponseEntity<Void> deleteApplication(@PathVariable Long id) {
    try {
      hackathonService.deleteApplication(id);
      return ResponseEntity.noContent().build();
    } catch (Exception e) {
      return ResponseEntity.status(500).build();
    }
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/dto/TeamMemberRequestDto.java
================================================
package com.kt.hackathon.be.application.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TeamMemberRequestDto {

  private String teamName;
  private String teamSize;
  private String teamDescription;
  private String ideaTitle;
  private String ideaDescription;
  private String problemStatement;
  private String solutionApproach;
  private String techStack;

  // 팀원 정보를 배열로 관리
  private List<TeamMemberDto> members;

  @Getter
  @Setter
  @NoArgsConstructor
  @AllArgsConstructor
  @Builder
  public static class TeamMemberDto {
    private String name;
    private String email;
    private String phone;
    private String role;
    private String department;
    private String position;
    private Boolean isLeader;
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/model/HackathonApplication.java
================================================
package com.kt.hackathon.be.application.model;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "hackathon_applications")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class HackathonApplication {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @OneToOne(fetch = FetchType.EAGER)
  @JoinColumn(name = "team_id")
  @JsonManagedReference
  private Team team;

  @Column(name = "idea_title")
  private String ideaTitle;

  @Column(name = "idea_description", columnDefinition = "TEXT")
  private String ideaDescription;

  @Column(name = "problem_statement", columnDefinition = "TEXT")
  private String problemStatement;

  @Column(name = "solution_approach", columnDefinition = "TEXT")
  private String solutionApproach;

  @Column(name = "tech_stack", columnDefinition = "TEXT")
  private String techStack;

  @Enumerated(EnumType.STRING)
  @Column(name = "status")
  private ApplicationStatus status;

  @Column(name = "first_create_datetime")
  private String firstCreateDatetime;

  @Column(name = "first_create_uid")
  private String firstCreateUid;

  @Column(name = "first_create_uid_ip")
  private String firstCreateUidIp;

  @Column(name = "last_update_datetime")
  private String lastUpdateDatetime;

  @Column(name = "last_update_uid")
  private String lastUpdateUid;

  @Column(name = "last_update_uid_ip")
  private String lastUpdateUidIp;

  public enum ApplicationStatus {
    PENDING,
    APPROVED,
    REJECTED
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/model/IdeaInfo.java
================================================
package com.kt.hackathon.be.application.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "idea_infos")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdeaInfo {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name = "title", nullable = false)
  private String title;

  @Column(name = "problem", nullable = false, length = 300)
  private String problem;

  @Column(name = "solution", nullable = false, length = 500)
  private String solution;

  @Column(name = "technology_stack")
  private String technologyStack;

  @OneToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "application_id")
  private HackathonApplication application;

  @Column(name = "first_create_datetime")
  private String firstCreateDatetime;

  @Column(name = "first_create_uid")
  private String firstCreateUid;

  @Column(name = "first_create_uid_ip")
  private String firstCreateUidIp;

  @Column(name = "last_update_datetime")
  private String lastUpdateDatetime;

  @Column(name = "last_update_uid")
  private String lastUpdateUid;

  @Column(name = "last_update_uid_ip")
  private String lastUpdateUidIp;
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/model/Team.java
================================================
package com.kt.hackathon.be.application.model;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "teams")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Team {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name = "team_name", nullable = false, unique = true)
  private String teamName;

  @Column(name = "team_size")
  private String teamSize;

  @Column(name = "team_description", columnDefinition = "TEXT")
  private String teamDescription;

  @OneToMany(mappedBy = "team", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
  @JsonManagedReference
  private List<TeamMember> members;

  @OneToOne(mappedBy = "team", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
  @JsonBackReference
  private HackathonApplication application;

  @Column(name = "first_create_datetime")
  private String firstCreateDatetime;

  @Column(name = "first_create_uid")
  private String firstCreateUid;

  @Column(name = "first_create_uid_ip")
  private String firstCreateUidIp;

  @Column(name = "last_update_datetime")
  private String lastUpdateDatetime;

  @Column(name = "last_update_uid")
  private String lastUpdateUid;

  @Column(name = "last_update_uid_ip")
  private String lastUpdateUidIp;
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/model/TeamMember.java
================================================
package com.kt.hackathon.be.application.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "team_members")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TeamMember {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name = "name", nullable = false)
  private String name;

  @Column(name = "email", nullable = false)
  private String email;

  @Column(name = "phone")
  private String phone;

  @Column(name = "role")
  private String role;

  @Column(name = "department")
  private String department;

  @Column(name = "position")
  private String position;

  @Column(name = "is_leader")
  private Boolean isLeader;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "team_id")
  @JsonBackReference
  private Team team;

  @Column(name = "first_create_datetime")
  private String firstCreateDatetime;

  @Column(name = "first_create_uid")
  private String firstCreateUid;

  @Column(name = "first_create_uid_ip")
  private String firstCreateUidIp;

  @Column(name = "last_update_datetime")
  private String lastUpdateDatetime;

  @Column(name = "last_update_uid")
  private String lastUpdateUid;

  @Column(name = "last_update_uid_ip")
  private String lastUpdateUidIp;
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/repository/HackathonApplicationRepository.java
================================================
package com.kt.hackathon.be.application.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.kt.hackathon.be.application.model.HackathonApplication;

@Repository
public interface HackathonApplicationRepository extends JpaRepository<HackathonApplication, Long> {

  @Query("SELECT ha FROM HackathonApplication ha WHERE ha.team.teamName = :teamName")
  List<HackathonApplication> findByTeamTeamName(@Param("teamName") String teamName);

  @Query(
      "SELECT ha FROM HackathonApplication ha JOIN ha.team t JOIN t.members tm WHERE tm.name = :memberName")
  List<HackathonApplication> findByTeamMembersName(@Param("memberName") String memberName);

  @Query(
      "SELECT ha FROM HackathonApplication ha JOIN ha.team t JOIN t.members tm WHERE tm.email = :memberEmail")
  List<HackathonApplication> findByTeamMembersEmail(@Param("memberEmail") String memberEmail);

  @Query(
      "SELECT ha FROM HackathonApplication ha JOIN ha.team t JOIN t.members tm WHERE t.teamName = :teamName AND tm.name = :memberName")
  List<HackathonApplication> findByTeamTeamNameAndTeamMembersName(
      @Param("teamName") String teamName, @Param("memberName") String memberName);
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/repository/TeamRepository.java
================================================
package com.kt.hackathon.be.application.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.kt.hackathon.be.application.model.Team;

@Repository
public interface TeamRepository extends JpaRepository<Team, Long> {
  Optional<Team> findByTeamName(String teamName);
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/application/service/HackathonService.java
================================================
package com.kt.hackathon.be.application.service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.kt.hackathon.be.application.dto.TeamMemberRequestDto;
import com.kt.hackathon.be.application.model.HackathonApplication;
import com.kt.hackathon.be.application.model.Team;
import com.kt.hackathon.be.application.model.TeamMember;
import com.kt.hackathon.be.application.repository.HackathonApplicationRepository;
import com.kt.hackathon.be.application.repository.TeamRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
@Transactional(rollbackFor = Exception.class)
public class HackathonService {

  private final HackathonApplicationRepository applicationRepository;
  private final TeamRepository teamRepository;

  public HackathonApplication createApplication(TeamMemberRequestDto request) {
    // 팀 생성 또는 기존 팀 조회
    Team team =
        teamRepository
            .findByTeamName(request.getTeamName())
            .orElseGet(
                () -> {
                  Team newTeam =
                      Team.builder()
                          .teamName(request.getTeamName())
                          .teamSize(request.getTeamSize())
                          .teamDescription(request.getTeamDescription())
                          .firstCreateDatetime(LocalDateTime.now().toString())
                          .firstCreateUid("system")
                          .firstCreateUidIp("127.0.0.1")
                          .lastUpdateDatetime(LocalDateTime.now().toString())
                          .lastUpdateUid("system")
                          .lastUpdateUidIp("127.0.0.1")
                          .build();
                  return teamRepository.save(newTeam);
                });

    // 팀원 정보 생성
    List<TeamMember> members = new ArrayList<>();

    if (request.getMembers() != null) {
      for (TeamMemberRequestDto.TeamMemberDto memberDto : request.getMembers()) {
        TeamMember member =
            TeamMember.builder()
                .name(memberDto.getName())
                .email(memberDto.getEmail())
                .phone(memberDto.getPhone())
                .role(memberDto.getRole())
                .department(memberDto.getDepartment())
                .position(memberDto.getPosition())
                .isLeader(memberDto.getIsLeader() != null ? memberDto.getIsLeader() : false)
                .team(team)
                .firstCreateDatetime(LocalDateTime.now().toString())
                .firstCreateUid("system")
                .firstCreateUidIp("127.0.0.1")
                .lastUpdateDatetime(LocalDateTime.now().toString())
                .lastUpdateUid("system")
                .lastUpdateUidIp("127.0.0.1")
                .build();
        members.add(member);
      }
    }

    // 팀에 팀원 정보 설정
    team.setMembers(members);

    // 해커톤 애플리케이션 생성
    HackathonApplication application =
        HackathonApplication.builder()
            .team(team)
            .ideaTitle(request.getIdeaTitle())
            .ideaDescription(request.getIdeaDescription())
            .problemStatement(request.getProblemStatement())
            .solutionApproach(request.getSolutionApproach())
            .techStack(request.getTechStack())
            .status(HackathonApplication.ApplicationStatus.PENDING)
            .firstCreateDatetime(LocalDateTime.now().toString())
            .firstCreateUid("system")
            .firstCreateUidIp("127.0.0.1")
            .lastUpdateDatetime(LocalDateTime.now().toString())
            .lastUpdateUid("system")
            .lastUpdateUidIp("127.0.0.1")
            .build();

    return applicationRepository.save(application);
  }

  @Transactional(readOnly = true)
  public List<HackathonApplication> getApplications(String teamName, String memberName) {
    try {
      List<HackathonApplication> applications;
      if (teamName != null && !teamName.trim().isEmpty()) {
        applications = applicationRepository.findByTeamTeamName(teamName.trim());
      } else if (memberName != null && !memberName.trim().isEmpty()) {
        // 이메일 형식인지 확인
        if (memberName.contains("@")) {
          applications = applicationRepository.findByTeamMembersEmail(memberName.trim());
        } else {
          applications = applicationRepository.findByTeamMembersName(memberName.trim());
        }
      } else {
        applications = applicationRepository.findAll();
      }

      // 팀 정보를 명시적으로 로드
      for (HackathonApplication application : applications) {
        if (application.getTeam() != null) {
          // 팀 정보 로드
          application.getTeam().getTeamName();
          // 팀원 정보 로드
          if (application.getTeam().getMembers() != null) {
            application.getTeam().getMembers().size();
          }
        }
      }

      return applications;
    } catch (Exception e) {
      // 로그 출력
      System.err.println("Error in getApplications: " + e.getMessage());
      e.printStackTrace();
      // 빈 리스트 반환
      return List.of();
    }
  }

  @Transactional(readOnly = true)
  public HackathonApplication getApplication(Long id) {
    return applicationRepository
        .findById(id)
        .orElseThrow(() -> new RuntimeException("Application not found with id: " + id));
  }

  public HackathonApplication updateApplication(Long id, TeamMemberRequestDto request) {
    HackathonApplication application = getApplication(id);

    // 팀 정보 업데이트
    if (request.getTeamName() != null) {
      Team team =
          teamRepository
              .findByTeamName(request.getTeamName())
              .orElseGet(
                  () -> {
                    Team newTeam =
                        Team.builder()
                            .teamName(request.getTeamName())
                            .teamSize(request.getTeamSize())
                            .teamDescription(request.getTeamDescription())
                            .build();
                    return teamRepository.save(newTeam);
                  });

      // 기존 팀원 정보 제거
      if (team.getMembers() != null) {
        team.getMembers().clear();
      }

      // 새로운 팀원 정보 추가
      if (request.getMembers() != null && !request.getMembers().isEmpty()) {
        System.out.println("팀원 정보 업데이트 - 팀원 수: " + request.getMembers().size());
        List<TeamMember> newMembers =
            request.getMembers().stream()
                .map(
                    memberDto -> {
                      System.out.println(
                          "팀원 정보: " + memberDto.getName() + " (" + memberDto.getEmail() + ")");
                      return TeamMember.builder()
                          .name(memberDto.getName())
                          .email(memberDto.getEmail())
                          .phone(memberDto.getPhone())
                          .role(memberDto.getRole())
                          .department(memberDto.getDepartment())
                          .position(memberDto.getPosition())
                          .isLeader(
                              memberDto.getIsLeader() != null ? memberDto.getIsLeader() : false)
                          .team(team)
                          .firstCreateDatetime(LocalDateTime.now().toString())
                          .firstCreateUid("system")
                          .firstCreateUidIp("127.0.0.1")
                          .lastUpdateDatetime(LocalDateTime.now().toString())
                          .lastUpdateUid("system")
                          .lastUpdateUidIp("127.0.0.1")
                          .build();
                    })
                .collect(Collectors.toList());

        team.setMembers(newMembers);
        System.out.println("팀원 정보 설정 완료 - 팀원 수: " + newMembers.size());
      }

      application.setTeam(team);
    } else {
      // 팀명이 변경되지 않았지만 팀 구성 정보나 팀원 정보를 업데이트하는 경우
      Team team = application.getTeam();
      if (team != null) {
        // 팀 구성 정보 업데이트
        if (request.getTeamSize() != null) {
          team.setTeamSize(request.getTeamSize());
        }
        if (request.getTeamDescription() != null) {
          team.setTeamDescription(request.getTeamDescription());
        }

        // 팀원 정보 업데이트
        if (request.getMembers() != null && !request.getMembers().isEmpty()) {
          // 기존 팀원 정보 제거
          if (team.getMembers() != null) {
            team.getMembers().clear();
          }

          // 새로운 팀원 정보 추가
          List<TeamMember> newMembers =
              request.getMembers().stream()
                  .map(
                      memberDto ->
                          TeamMember.builder()
                              .name(memberDto.getName())
                              .email(memberDto.getEmail())
                              .phone(memberDto.getPhone())
                              .role(memberDto.getRole())
                              .department(memberDto.getDepartment())
                              .position(memberDto.getPosition())
                              .isLeader(
                                  memberDto.getIsLeader() != null ? memberDto.getIsLeader() : false)
                              .team(team)
                              .firstCreateDatetime(LocalDateTime.now().toString())
                              .firstCreateUid("system")
                              .firstCreateUidIp("127.0.0.1")
                              .lastUpdateDatetime(LocalDateTime.now().toString())
                              .lastUpdateUid("system")
                              .lastUpdateUidIp("127.0.0.1")
                              .build())
                  .collect(Collectors.toList());

          team.setMembers(newMembers);
        }
      }
    }

    // 아이디어 정보 업데이트
    if (request.getIdeaTitle() != null) {
      application.setIdeaTitle(request.getIdeaTitle());
    }
    if (request.getIdeaDescription() != null) {
      application.setIdeaDescription(request.getIdeaDescription());
    }
    if (request.getProblemStatement() != null) {
      application.setProblemStatement(request.getProblemStatement());
    }
    if (request.getSolutionApproach() != null) {
      application.setSolutionApproach(request.getSolutionApproach());
    }
    if (request.getTechStack() != null) {
      application.setTechStack(request.getTechStack());
    }

    return applicationRepository.save(application);
  }

  public void deleteApplication(Long id) {
    applicationRepository.deleteById(id);
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/config/CorsConfig.java
================================================
package com.kt.hackathon.be.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

  @Override
  public void addCorsMappings(CorsRegistry registry) {
    registry
        .addMapping("/**")
        .allowedOriginPatterns("*")
        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
        .allowedHeaders("*")
        .allowCredentials(true)
        .maxAge(3600);
  }

  @Bean
  public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.addAllowedOriginPattern("*");
    configuration.addAllowedMethod("*");
    configuration.addAllowedHeader("*");
    configuration.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
  }
}



================================================
FILE: backend/src/main/java/com/kt/hackathon/be/config/SwaggerConfig.java
================================================
package com.kt.hackathon.be.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;

@Configuration
public class SwaggerConfig {

  @Bean
  public OpenAPI openAPI() {
    return new OpenAPI()
        .info(
            new Info()
                .title("Hackathon API")
                .description("해커톤 애플리케이션 관리 API")
                .version("1.0.0")
                .contact(new Contact().name("KT Hackathon Team").email("hackathon@kt.com")));
  }
}



================================================
FILE: backend/src/main/resources/application-prd.yml
================================================
server:
  port: 8080

spring:
  application:
    name: hackathon-backend
  
  datasource:
    url: jdbc:postgresql://hackathon-postgres:5432/hackathon_db
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    com.kt.hackathon: INFO
    org.hibernate.SQL: INFO
    # org.hibernate.type.descriptor.sql.BasicBinder: TRACE


================================================
FILE: backend/src/main/resources/application-test.yml
================================================
server:
  port: 8080

spring:
  application:
    name: hackathon-backend
  
  datasource:
    url: jdbc:postgresql://host.docker.internal:5432/hackathon_db
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    com.kt.hackathon: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE


================================================
FILE: backend/src/main/resources/application.yml
================================================
server:
  port: 8080

spring:
  application:
    name: hackathon-backend
  
  datasource:
    url: jdbc:postgresql://localhost:5432/hackathon_db
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    com.kt.hackathon: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE


================================================
FILE: backend/src/main/resources/db/migration/common_sql/V1_1_001_1__create_teams_table.sql
================================================
CREATE TABLE teams (
    id BIGSERIAL PRIMARY KEY,
    team_name VARCHAR(255) NOT NULL UNIQUE,
    team_size VARCHAR(50),
    team_description TEXT,
    first_create_datetime VARCHAR(50),
    first_create_uid VARCHAR(100),
    first_create_uid_ip VARCHAR(50),
    last_update_datetime VARCHAR(50),
    last_update_uid VARCHAR(100),
    last_update_uid_ip VARCHAR(50)
);

-- 인덱스 생성
CREATE INDEX ix_teams_team_name ON teams(team_name); 


================================================
FILE: backend/src/main/resources/db/migration/common_sql/V1_1_002_1__create_team_members_table.sql
================================================
CREATE TABLE team_members (
    id BIGSERIAL PRIMARY KEY,
    team_id BIGINT NOT NULL,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(50),
    role VARCHAR(100),
    department VARCHAR(255),
    position VARCHAR(100),
    is_leader BOOLEAN DEFAULT FALSE,
    first_create_datetime VARCHAR(50),
    first_create_uid VARCHAR(100),
    first_create_uid_ip VARCHAR(50),
    last_update_datetime VARCHAR(50),
    last_update_uid VARCHAR(100),
    last_update_uid_ip VARCHAR(50),
    FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE
);

-- 인덱스 생성
CREATE INDEX ix_team_members_team_id ON team_members(team_id);
CREATE INDEX ix_team_members_email ON team_members(email);
CREATE INDEX ix_team_members_name ON team_members(name); 


================================================
FILE: backend/src/main/resources/db/migration/common_sql/V1_1_003_1__create_hackathon_applications_table.sql
================================================
CREATE TABLE hackathon_applications (
    id BIGSERIAL PRIMARY KEY,
    team_id BIGINT NOT NULL,
    idea_title VARCHAR(500),
    idea_description TEXT,
    problem_statement TEXT,
    solution_approach TEXT,
    tech_stack TEXT,
    status VARCHAR(20) DEFAULT 'PENDING',
    first_create_datetime VARCHAR(50),
    first_create_uid VARCHAR(100),
    first_create_uid_ip VARCHAR(50),
    last_update_datetime VARCHAR(50),
    last_update_uid VARCHAR(100),
    last_update_uid_ip VARCHAR(50),
    FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE
);

-- 인덱스 생성
CREATE INDEX ix_hackathon_applications_team_id ON hackathon_applications(team_id);
CREATE INDEX ix_hackathon_applications_status ON hackathon_applications(status); 


================================================
FILE: backend/src/test/java/com/kt/hackathon/be/HackathonServiceTest.java
================================================
package com.kt.hackathon.be;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.kt.hackathon.be.application.dto.TeamMemberRequestDto;
import com.kt.hackathon.be.application.model.HackathonApplication;
import com.kt.hackathon.be.application.model.Team;
import com.kt.hackathon.be.application.repository.HackathonApplicationRepository;
import com.kt.hackathon.be.application.repository.TeamRepository;
import com.kt.hackathon.be.application.service.HackathonService;

@ExtendWith(MockitoExtension.class)
class HackathonServiceTest {

  @Mock private TeamRepository teamRepository;

  @Mock private HackathonApplicationRepository applicationRepository;

  @InjectMocks private HackathonService hackathonService;

  private TeamMemberRequestDto requestDto;
  private Team team;
  private HackathonApplication application;

  @BeforeEach
  void setUp() {
    // 팀원 정보 생성
    TeamMemberRequestDto.TeamMemberDto leaderDto =
        TeamMemberRequestDto.TeamMemberDto.builder()
            .name("홍길동")
            .email("hong@test.com")
            .phone("010-1234-5678")
            .role("팀장")
            .department("개발팀")
            .position("개발자")
            .isLeader(true)
            .build();

    TeamMemberRequestDto.TeamMemberDto memberDto =
        TeamMemberRequestDto.TeamMemberDto.builder()
            .name("김철수")
            .email("kim@test.com")
            .phone("010-2345-6789")
            .role("개발자")
            .department("개발팀")
            .position("개발자")
            .isLeader(false)
            .build();

    requestDto =
        TeamMemberRequestDto.builder()
            .teamName("테스트팀")
            .teamSize("2")
            .teamDescription("AI 개발 전문팀")
            .ideaTitle("AI 챗봇")
            .ideaDescription("AI 기반 고객 서비스 챗봇")
            .problemStatement("고객 문의 응답 지연 문제")
            .solutionApproach("AI 기술을 활용한 자동 응답 시스템")
            .techStack("Python, TensorFlow, React")
            .members(List.of(leaderDto, memberDto))
            .build();

    team =
        Team.builder().id(1L).teamName("테스트팀").teamSize("2").teamDescription("AI 개발 전문팀").build();

    application =
        HackathonApplication.builder()
            .id(1L)
            .team(team)
            .ideaTitle("AI 챗봇")
            .ideaDescription("AI 기반 고객 서비스 챗봇")
            .problemStatement("고객 문의 응답 지연 문제")
            .solutionApproach("AI 기술을 활용한 자동 응답 시스템")
            .techStack("Python, TensorFlow, React")
            .status(HackathonApplication.ApplicationStatus.PENDING)
            .build();
  }

  @Test
  void createApplication_새로운팀으로생성_성공() {
    // given
    when(teamRepository.findByTeamName("테스트팀")).thenReturn(Optional.empty());
    when(teamRepository.save(any(Team.class))).thenReturn(team);
    when(applicationRepository.save(any(HackathonApplication.class))).thenReturn(application);

    // when
    HackathonApplication result = hackathonService.createApplication(requestDto);

    // then
    assertNotNull(result);
    assertEquals("테스트팀", result.getTeam().getTeamName());
    assertEquals("AI 챗봇", result.getIdeaTitle());
    assertEquals("고객 문의 응답 지연 문제", result.getProblemStatement());
    assertEquals("AI 기술을 활용한 자동 응답 시스템", result.getSolutionApproach());
    assertEquals("Python, TensorFlow, React", result.getTechStack());
    assertEquals(HackathonApplication.ApplicationStatus.PENDING, result.getStatus());

    verify(teamRepository).findByTeamName("테스트팀");
    verify(teamRepository).save(any(Team.class));
    verify(applicationRepository).save(any(HackathonApplication.class));
  }

  @Test
  void createApplication_기존팀으로생성_성공() {
    // given
    when(teamRepository.findByTeamName("테스트팀")).thenReturn(Optional.of(team));
    when(applicationRepository.save(any(HackathonApplication.class))).thenReturn(application);

    // when
    HackathonApplication result = hackathonService.createApplication(requestDto);

    // then
    assertNotNull(result);
    assertEquals("테스트팀", result.getTeam().getTeamName());

    verify(teamRepository).findByTeamName("테스트팀");
    verify(teamRepository, never()).save(any(Team.class));
    verify(applicationRepository).save(any(HackathonApplication.class));
  }

  @Test
  void getApplications_팀명으로조회_성공() {
    // given
    List<HackathonApplication> applications = List.of(application);
    when(applicationRepository.findByTeamTeamName("테스트팀")).thenReturn(applications);

    // when
    List<HackathonApplication> result = hackathonService.getApplications("테스트팀", null);

    // then
    assertNotNull(result);
    assertEquals(1, result.size());
    assertEquals("테스트팀", result.get(0).getTeam().getTeamName());

    verify(applicationRepository).findByTeamTeamName("테스트팀");
  }

  @Test
  void getApplications_전체조회_성공() {
    // given
    List<HackathonApplication> applications = List.of(application);
    when(applicationRepository.findAll()).thenReturn(applications);

    // when
    List<HackathonApplication> result = hackathonService.getApplications(null, null);

    // then
    assertNotNull(result);
    assertEquals(1, result.size());

    verify(applicationRepository).findAll();
  }

  @Test
  void getApplication_존재하는애플리케이션조회_성공() {
    // given
    when(applicationRepository.findById(1L)).thenReturn(Optional.of(application));

    // when
    HackathonApplication result = hackathonService.getApplication(1L);

    // then
    assertNotNull(result);
    assertEquals(1L, result.getId());

    verify(applicationRepository).findById(1L);
  }

  @Test
  void getApplication_존재하지않는애플리케이션조회_예외발생() {
    // given
    when(applicationRepository.findById(999L)).thenReturn(Optional.empty());

    // when & then
    RuntimeException exception =
        assertThrows(RuntimeException.class, () -> hackathonService.getApplication(999L));

    assertEquals("Application not found with id: 999", exception.getMessage());
    verify(applicationRepository).findById(999L);
  }

  @Test
  void getApplications_멤버명으로조회_성공() {
    // given
    List<HackathonApplication> applications = List.of(application);
    when(applicationRepository.findByTeamMembersName("김개발")).thenReturn(applications);

    // when
    List<HackathonApplication> result = hackathonService.getApplications(null, "김개발");

    // then
    assertNotNull(result);
    assertEquals(1, result.size());

    verify(applicationRepository).findByTeamMembersName("김개발");
  }

  @Test
  void getApplications_조회중예외발생_빈리스트반환() {
    // given
    when(applicationRepository.findByTeamTeamName("테스트팀"))
        .thenThrow(new RuntimeException("Database error"));

    // when
    List<HackathonApplication> result = hackathonService.getApplications("테스트팀", null);

    // then
    assertNotNull(result);
    assertTrue(result.isEmpty());

    verify(applicationRepository).findByTeamTeamName("테스트팀");
  }

  @Test
  void updateApplication_아이디어정보수정_성공() {
    // given
    TeamMemberRequestDto updateDto =
        TeamMemberRequestDto.builder()
            .ideaTitle("수정된 아이디어")
            .ideaDescription("수정된 설명")
            .problemStatement("수정된 문제")
            .solutionApproach("수정된 해결방법")
            .techStack("수정된 기술스택")
            .build();

    when(applicationRepository.findById(1L)).thenReturn(Optional.of(application));
    when(applicationRepository.save(any(HackathonApplication.class))).thenReturn(application);

    // when
    HackathonApplication result = hackathonService.updateApplication(1L, updateDto);

    // then
    assertNotNull(result);
    assertEquals("수정된 아이디어", result.getIdeaTitle());
    assertEquals("수정된 설명", result.getIdeaDescription());
    assertEquals("수정된 문제", result.getProblemStatement());
    assertEquals("수정된 해결방법", result.getSolutionApproach());
    assertEquals("수정된 기술스택", result.getTechStack());

    verify(applicationRepository).findById(1L);
    verify(applicationRepository).save(any(HackathonApplication.class));
  }

  @Test
  void updateApplication_팀명변경_성공() {
    // given
    TeamMemberRequestDto updateDto =
        TeamMemberRequestDto.builder()
            .teamName("새로운팀명")
            .teamSize("3")
            .teamDescription("새로운 팀 설명")
            .build();

    Team newTeam =
        Team.builder().id(2L).teamName("새로운팀명").teamSize("3").teamDescription("새로운 팀 설명").build();

    when(applicationRepository.findById(1L)).thenReturn(Optional.of(application));
    when(teamRepository.findByTeamName("새로운팀명")).thenReturn(Optional.empty());
    when(teamRepository.save(any(Team.class))).thenReturn(newTeam);
    when(applicationRepository.save(any(HackathonApplication.class))).thenReturn(application);

    // when
    HackathonApplication result = hackathonService.updateApplication(1L, updateDto);

    // then
    assertNotNull(result);

    verify(applicationRepository).findById(1L);
    verify(teamRepository).findByTeamName("새로운팀명");
    verify(teamRepository).save(any(Team.class));
    verify(applicationRepository).save(any(HackathonApplication.class));
  }

  @Test
  void updateApplication_존재하지않는애플리케이션수정_예외발생() {
    // given
    TeamMemberRequestDto updateDto = TeamMemberRequestDto.builder().ideaTitle("수정된 아이디어").build();

    when(applicationRepository.findById(999L)).thenReturn(Optional.empty());

    // when & then
    RuntimeException exception =
        assertThrows(
            RuntimeException.class, () -> hackathonService.updateApplication(999L, updateDto));

    assertEquals("Application not found with id: 999", exception.getMessage());
    verify(applicationRepository).findById(999L);
  }

  @Test
  void deleteApplication_애플리케이션삭제_성공() {
    // given
    doNothing().when(applicationRepository).deleteById(1L);

    // when
    hackathonService.deleteApplication(1L);

    // then
    verify(applicationRepository).deleteById(1L);
  }
}



================================================
FILE: frontend/README.md
================================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```



================================================
FILE: frontend/cypress.config.js
================================================
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:5173',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    viewportWidth: 1280,
    viewportHeight: 720,
    video: false,
    screenshotOnRunFailure: true,
    defaultCommandTimeout: 10000,
    requestTimeout: 10000,
    responseTimeout: 10000,
  },
}); 


================================================
FILE: frontend/Dockerfile
================================================
FROM mcr.microsoft.com/azurelinux/base/nodejs:20.14 AS build
WORKDIR /app

COPY . .
RUN npm install
RUN npm run build:prod

FROM mcr.microsoft.com/azurelinux/base/nginx:1.25
COPY --from=build /app/dist/ /app/
COPY --from=build /app/src/assets/ /app/assets/

COPY nginx.conf /etc/nginx/nginx.conf
WORKDIR /app

CMD ["nginx", "-g", "daemon off;"]


================================================
FILE: frontend/Dockerfile.test
================================================
FROM mcr.microsoft.com/azurelinux/base/nodejs:20.14 AS build
WORKDIR /app

COPY . .
RUN npm install
RUN npm run build:test

FROM mcr.microsoft.com/azurelinux/base/nginx:1.25
COPY --from=build /app/dist/ /app/
COPY --from=build /app/src/assets/ /app/assets/

COPY nginx.conf /etc/nginx/nginx.conf
WORKDIR /app

CMD ["nginx", "-g", "daemon off;"]


================================================
FILE: frontend/eslint.config.js
================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import jest from 'eslint-plugin-jest'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
  {
    files: ['**/*.test.{ts,tsx}', '**/*.spec.{ts,tsx}'],
    plugins: { jest },
    rules: {
      ...jest.configs.recommended.rules,
    },
  },
])



================================================
FILE: frontend/frontend-test-scenarios.md
================================================
[Binary file]


================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: frontend/jest.config.js
================================================
export default {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/main.tsx',
  ],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: 'tsconfig.app.json',
      useESM: true,
    }],
  },
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{ts,tsx}',
    '<rootDir>/src/**/*.{test,spec}.{ts,tsx}',
  ],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  transformIgnorePatterns: [
    'node_modules/(?!axios/)',
  ],
  testEnvironmentOptions: {
    customExportConditions: ['node', 'node-addons'],
  },
}; 


================================================
FILE: frontend/nginx.conf
================================================
events {
    worker_connections  1024;
}

http{
    server {
        listen 8080;

        root /app;

        index index.html;

        location / {
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST' always;
            add_header 'Access-Control-Allow-Headers' '*' always;
            try_files $uri $uri/ /index.html;
            include /etc/nginx/mime.types;
        }

        # location /api {
        #     proxy_pass http://bootcamp-sample-be:8080/api;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #     proxy_set_header X-Forwarded-Proto $scheme;
            
        #     # CORS
        #     add_header 'Access-Control-Allow-Origin' '*' always;
        #     add_header 'Access-Control-Allow-Methods' 'POST, OPTIONS' always;
        #     add_header 'Access-Control-Allow-Headers' '*' always;
        # }

        location /healthy {
            return 200 'Server is Running..';
        }

        access_log on;  
        # access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;
    }
}


================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "prod": "vite --mode production",
    "build": "vite build",
    "build:test": "vite build --mode test",
    "build:prod": "vite build --mode production",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "cypress:open": "cypress open",
    "cypress:run": "cypress run",
    "test:e2e": "cypress run",
    "test:all": "npm run test && npm run test:e2e",
    "format": "prettier --write \"src/**/*.{ts,tsx}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx}\""
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.2.0",
    "@mui/material": "^7.2.0",
    "@types/node": "^24.1.0",
    "axios": "^1.11.0",
    "lucide-react": "^0.536.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.7.1",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@testing-library/jest-dom": "^6.6.4",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/jest": "^30.0.0",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "cypress": "^14.5.3",
    "eslint": "^9.30.1",
    "eslint-plugin-jest": "^29.0.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "jest": "^30.0.5",
    "jest-environment-jsdom": "^30.0.5",
    "prettier": "^3.6.2",
    "ts-jest": "^29.4.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.35.1",
    "vite": "^7.0.4"
  }
}



================================================
FILE: frontend/test-scenario-generation-prompt.md
================================================
# 프론트엔드 테스트 시나리오 생성 프롬프트

다음 정보를 바탕으로 프론트엔드 테스트 시나리오를 생성해주세요:

## 입력 정보

### 테스트 전략 문서
첨부파일 참조

### 소스 코드 구조
소스 참조

## 요구사항

1. **전략 문서 기준 준수**
   - 교육 환경 특화 (2일 제한)
   - 핵심 기능 우선 테스트
   - 백엔드 커버리지 70% 이상, 프론트엔드는 제외
   - 접근성, 성능, 반응형 테스트 제외

2. **실제 구현 기능만 테스트**
   - 소스 코드 분석 후 실제 기능만 식별
   - 미구현 기능 (인증, 로그인 등) 제외
   - 실제 API 엔드포인트만 테스트

3. **출력 형식**
   - TC-UNIT: 단위 테스트 시나리오
   - TC-MODULE: 모듈 테스트 시나리오
   - TC-E2E: E2E 테스트 시나리오
   - 우선순위 설정 (높음/중간/낮음)
   - 테스트 실행 순서
   - 완료 기준

## 제약사항
- 실제 구현되지 않은 기능은 절대 포함하지 마세요
- 전략 문서의 교육 환경 특성을 반영하세요
- 접근성, 성능, 반응형 테스트는 제외하세요
- 인증 관련 기능이 없으면 제외하세요
- 커버리지 목표는 백엔드만, 프론트엔드는 제외하세요
- 테스트 환경 설정 코드는 포함하지 마세요

## 분석 단계

### Step 1: 전략 문서 기반 테스트 범위 설정
- 단위 테스트: Jest + React Testing Library
- 모듈 테스트: Cypress Intercept
- E2E 테스트: Cypress
- 교육 환경 특화 (핵심 기능 우선)

### Step 2: 소스 코드 기반 실제 기능 식별
- 컴포넌트별 실제 구현 기능 파악
- API 호출 로직 분석
- 상태 관리 로직 확인
- 미구현 기능 제외

### Step 3: 테스트 시나리오 생성
- 실제 구현된 기능만 테스트 시나리오 작성
- 전략 문서의 우선순위 적용
- 교육 환경에 적합한 범위 설정

## 출력 형식 예시

```markdown
# AI Agentic Boot Camp 프론트엔드 테스트 시나리오

## 📋 프로젝트 정보
- **프로젝트명**: AI Agentic Boot Camp 해커톤 신청 사이트
- **테스트 환경**: React 19 + TypeScript + Vite + Material-UI
- **테스트 도구**: Jest (단위), Cypress (E2E)
- **상태관리**: Zustand (HackathonStore)
- **HTTP 클라이언트**: Axios

---

## 🧪 TC-UNIT (단위 테스트 시나리오)

### TC-UNIT-001: [컴포넌트명] 테스트
- **목적**: [목적 설명]
- **검증 항목**: 
  - [구체적인 검증 항목들]
- **도구**: Jest + React Testing Library

---

## 🔄 TC-MODULE (모듈 테스트 시나리오)

### TC-MODULE-001: [기능명] API 모킹 테스트
- **목적**: [목적 설명]
- **검증 항목**: 
  - [구체적인 검증 항목들]
- **도구**: Cypress Intercept

---

## 🎯 TC-E2E (E2E 테스트 시나리오)

### TC-E2E-001: [사용자 시나리오] 테스트
**Given** [전제 조건]
**When** [사용자 행동]
**Then** [예상 결과]

**검증 세부사항**:
- [구체적인 검증 항목들]

---

## 📊 테스트 우선순위

### 높은 우선순위 (핵심 기능)
- [핵심 기능 테스트 목록]

### 중간 우선순위 (사용자 경험)
- [중요 기능 테스트 목록]

### 낮은 우선순위 (부가 기능)
- [선택 기능 테스트 목록]

---

## 📝 테스트 실행 순서

1. **단위 테스트 실행** (Jest)
   - TC-UNIT-001 ~ TC-UNIT-XXX

2. **모듈 테스트 실행** (Cypress Intercept)
   - TC-MODULE-001 ~ TC-MODULE-XXX

3. **E2E 테스트 실행** (Cypress)
   - TC-E2E-001 ~ TC-E2E-XXX

---

## ✅ 테스트 완료 기준

- **단위 테스트**: 모든 TC-UNIT 시나리오 통과
- **모듈 테스트**: 모든 TC-MODULE 시나리오 통과
- **E2E 테스트**: 모든 TC-E2E 시나리오 통과
- **타입 체크**: TypeScript 컴파일 오류 없음

---

## 📈 성공 지표

- **단위 테스트 커버리지**: [목표 없음 - 프론트엔드 제외]
- **모듈 테스트 통과율**: 100%
- **E2E 테스트 통과율**: 100%
- **타입 안정성**: TypeScript 오류 0개
- **성능 점수**: Lighthouse 90점 이상
```

## 사용 방법

1. 위 프롬프트를 AI 도구에 입력
2. 테스트 전략 문서 내용을 [전략 문서 내용 붙여넣기] 부분에 붙여넣기
3. 실제 소스 코드 구조를 확인하여 파일 목록 업데이트
4. AI가 생성한 시나리오 검토 및 필요시 수정

## 주의사항

- 실제 구현되지 않은 기능은 반드시 제외
- 전략 문서의 교육 환경 특성을 정확히 반영
- 접근성, 성능, 반응형 테스트는 절대 포함하지 않음
- 인증 관련 기능이 없으면 제외
- 커버리지 목표는 백엔드만, 프론트엔드는 제외 


================================================
FILE: frontend/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": false,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "isolatedModules": true,

    /* Types */
    "types": ["jest", "@testing-library/jest-dom"],
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "resolveJsonModule": true
  },
  "include": ["src", "src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["node_modules"]
}



================================================
FILE: frontend/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



================================================
FILE: frontend/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: frontend/vite.config.ts
================================================
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig(({ mode }) => {
  // 환경 변수 로드
  const env = loadEnv(mode, process.cwd(), '')
  
  return {
    plugins: [react()],
    server: {
      proxy: {
        '/api': {
          target: env.VITE_API_BASE_URL || 'http://localhost:8080',
          changeOrigin: true,
          secure: false,
        },
      },
    },
  }
})



================================================
FILE: frontend/.env.development
================================================
VITE_API_BASE_URL=http://127.0.0.1:8080


================================================
FILE: frontend/.env.production
================================================
VITE_API_BASE_URL=https://bootcamp-sample-be.happybush-b58ba0d4.koreacentral.azurecontainerapps.io


================================================
FILE: frontend/.env.test
================================================
VITE_API_BASE_URL=http://127.0.0.1:8080


================================================
FILE: frontend/.prettierrc
================================================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
} 


================================================
FILE: frontend/cypress/e2e/module-tests.cy.ts
================================================
[Binary file]


================================================
FILE: frontend/cypress/support/commands.ts
================================================
// ***********************************************
// This example commands.ts shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************

declare global {
  namespace Cypress {
    interface Chainable {
      // Add custom commands here
    }
  }
}

// Example custom command
// Cypress.Commands.add('login', (email, password) => { ... })

export {}; 


================================================
FILE: frontend/cypress/support/e2e.ts
================================================
// ***********************************************************
// This example support/e2e.ts is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import './commands';

// Alternatively you can use CommonJS syntax:
// require('./commands')

// Hide fetch/XHR requests from command log
const app = window.top;
if (app && !app.document.head.querySelector('[data-hide-command-log-request]')) {
  const style = app.document.createElement('style');
  style.innerHTML =
    '.command-name-request, .command-name-xhr { display: none }';
  style.setAttribute('data-hide-command-log-request', '');
  app.document.head.appendChild(style);
} 


================================================
FILE: frontend/src/App.tsx
================================================
import { ThemeProvider } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { theme } from './theme';
import Navigation from './components/Navigation';
import IntroSection from './components/IntroSection';
import ParticipationSection from './components/ParticipationSection';
import RegistrationSection from './components/RegistrationSection';
import ConfirmationSection from './components/ConfirmationSection';

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <div className="App">
        <Navigation />
        <div style={{ paddingTop: 70 }}>
          <div id="intro">
            <IntroSection />
          </div>
          <div id="participation">
            <ParticipationSection />
          </div>
          <div id="registration">
            <RegistrationSection />
          </div>
          <div id="confirmation">
            <ConfirmationSection />
          </div>
        </div>
      </div>
    </ThemeProvider>
  );
}

export default App;



================================================
FILE: frontend/src/main.tsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)



================================================
FILE: frontend/src/setupTests.ts
================================================
import '@testing-library/jest-dom';

// import.meta.env 모킹
Object.defineProperty(globalThis, 'import', {
  value: {
    meta: {
      env: {
        VITE_API_BASE_URL: 'http://localhost:8080',
      },
    },
  },
  writable: true,
  configurable: true,
});

// jest-dom 타입 확장
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeInTheDocument(): R;
      toHaveValue(value: string | number | string[]): R;
      toHaveTextContent(text: string | RegExp): R;
    }
  }
}

// Material-UI 테스트를 위한 설정
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: any) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {}, // deprecated
    removeListener: () => {}, // deprecated
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// ResizeObserver 모킹 (Material-UI에서 사용)
(globalThis as any).ResizeObserver = class ResizeObserver {
  observe() {}
  unobserve() {}
  disconnect() {}
}; 


================================================
FILE: frontend/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: frontend/src/__mocks__/envMock.ts
================================================
export default {
  VITE_API_BASE_URL: 'http://localhost:8080',
}; 


================================================
FILE: frontend/src/api/axios.ts
================================================
import axios from 'axios';

// 환경 변수 안전하게 처리
const getBaseURL = () => {
  // Jest 환경에서는 기본값 사용
  if (typeof jest !== 'undefined') {
    return 'http://localhost:8080';
  }
  
  // 환경 변수에서 API 기본 URL 가져오기
  const apiBaseURL = import.meta.env.VITE_API_BASE_URL;
  
  // 환경 변수가 있으면 사용, 없으면 프록시 사용
  if (apiBaseURL) {
    return apiBaseURL;
  }
  
  // 개발 환경에서는 프록시 사용
  return '';
};

// const baseURL = getBaseURL();

declare global {
  interface ImportMetaEnv {
    VITE_API_BASE_URL?: string;
  }
}

export const axiosInstance = axios.create({
  // baseURL: baseURL,
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
axiosInstance.interceptors.request.use(
  (config) => {
    // Add auth token if available
    const token = localStorage.getItem('AUTH_TOKEN');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response?.status === 401) {
      // Handle unauthorized access
      localStorage.removeItem('AUTH_TOKEN');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
); 


================================================
FILE: frontend/src/api/__tests__/axios.test.ts
================================================
// axios 모듈을 모킹하여 import.meta.env 문제를 우회
jest.mock('../axios', () => ({
  axiosInstance: {
    defaults: {
      timeout: 10000,
      headers: { 'Content-Type': 'application/json' },
      baseURL: 'http://localhost:8080',
    },
    interceptors: {
      request: { handlers: [{}] },
      response: { handlers: [{}] },
    },
  },
}));

import { axiosInstance } from '../axios';

// localStorage 모킹
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

describe('Axios Configuration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.getItem.mockClear();
    localStorageMock.removeItem.mockClear();
  });

  describe('TC-UNIT-018: Axios 설정 테스트', () => {
    it('타임아웃 설정 검증', () => {
      // Given & When
      const timeout = (axiosInstance as any).defaults.timeout;

      // Then
      expect(timeout).toBe(10000);
    });

    it('기본 헤더 설정 검증', () => {
      // Given & When
      const headers = (axiosInstance as any).defaults.headers;

      // Then
      expect(headers['Content-Type']).toBe('application/json');
    });

    it('baseURL 설정 검증', () => {
      // Given & When
      const baseURL = (axiosInstance as any).defaults.baseURL;

      // Then
      expect(baseURL).toBe('http://localhost:8080');
    });

    it('요청 인터셉터 존재 확인', () => {
      // Given & When
      const requestInterceptors = (axiosInstance.interceptors.request as any).handlers;

      // Then
      expect(requestInterceptors).toBeDefined();
      expect(requestInterceptors.length).toBeGreaterThan(0);
    });

    it('응답 인터셉터 존재 확인', () => {
      // Given & When
      const responseInterceptors = (axiosInstance.interceptors.response as any).handlers;

      // Then
      expect(responseInterceptors).toBeDefined();
      expect(responseInterceptors.length).toBeGreaterThan(0);
    });
  });
}); 


================================================
FILE: frontend/src/components/ConfirmationSection.tsx
================================================
import React, { useState } from 'react';
import { Box, Typography, Paper, TextField, Button, Alert, Snackbar, Chip } from '@mui/material';
import { styled } from '@mui/material/styles';
import SearchIcon from '@mui/icons-material/Search';
import { HackathonService } from '../services/HackathonService';
import type { HackathonApplication } from '../model/types';

const ConfirmationContainer = styled(Box)(() => ({
  backgroundColor: '#f9fafb',
  padding: '70px 568px',
  paddingBottom: 200,
  minHeight: '100vh',
}));

const ContentContainer = styled(Box)(() => ({
  maxWidth: 784,
  margin: '0 auto',
  padding: '0 21px',
}));

const HeaderSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '21px',
  marginBottom: '42px',
}));

const SearchCard = styled(Paper)(() => ({
  backgroundColor: '#ffffff',
  borderRadius: 12.75,
  border: '1px solid rgba(0,0,0,0.01)',
  marginBottom: '21px',
  boxShadow: 'none',
  transition: 'box-shadow 0.2s ease',
  '&:hover': {
    boxShadow: '0px 4px 6px rgba(0, 0, 0, 0.1)',
  },
}));

const CardHeader = styled(Box)(() => ({
  padding: '21px 21px 5.25px 21px',
  display: 'flex',
  alignItems: 'center',
  gap: '10.5px',
  marginBottom: '10px',
}));

const CardContent = styled(Box)(() => ({
  padding: '0 21px 21px 21px',
  '& .MuiFormControl-root': {
    '& .MuiInputLabel-root': {
      marginBottom: '7px',
    },
  },
}));

const SearchIconBox = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  width: 21,
  height: 21,
  color: '#9810fa',
  marginRight: 3,
}));

const SearchForm = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  gap: '7px',
}));

const InputRow = styled(Box)(() => ({
  display: 'flex',
  gap: '14px',
  alignItems: 'flex-end',
}));

const FieldLabel = styled(Typography)(() => ({
  fontSize: '12.3px',
  color: '#0a0a0a',
  fontWeight: 500,
  lineHeight: '12.25px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const StyledTextField = styled(TextField)(() => ({
  width: '100%',
  '& .MuiOutlinedInput-root': {
    backgroundColor: '#f3f3f5',
    borderRadius: '6.75px',
    width: '100%',
    height: '31.5px',
    '& fieldset': {
      border: 'none',
    },
    '& input': {
      fontSize: '12.3px',
      padding: '8.5px 11.5px',
      color: '#717182',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
      lineHeight: 'normal',
      height: '31.5px',
      minHeight: '31.5px',
      width: '100%',
    },
    '& input::placeholder': {
      color: '#717182',
      opacity: 1,
      fontSize: '12.3px',
    },
    '&:hover': {
      backgroundColor: '#e2e8f0',
    },
    '&.Mui-focused': {
      backgroundColor: '#ffffff',
      border: '1px solid #9810fa',
    },
  },
  '& .MuiInputBase-input::placeholder': {
    color: '#717182',
    opacity: 1,
    fontSize: '12.3px',
  },
}));

const SearchButton = styled(Button)(() => ({
  backgroundColor: '#9810fa',
  color: '#ffffff',
  fontSize: '12.3px',
  fontWeight: 500,
  padding: '7px 21px',
  borderRadius: '6.75px',
  textTransform: 'none',
  lineHeight: '17.5px',
  width: '100px',
  height: '31.5px',
  minWidth: 'auto',
  '&:hover': {
    backgroundColor: '#59168b',
  },
}));

const InfoCard = styled(Paper)(() => ({
  backgroundColor: '#eff6ff',
  borderRadius: 12.75,
  border: '1px solid #bedbff',
  padding: '21px',
  marginBottom: '21px',
  transition: 'box-shadow 0.2s ease',
  '&:hover': {
    boxShadow: '0px 4px 6px rgba(0, 0, 0, 0.1)',
  },
}));

const InfoTitle = styled(Typography)(() => ({
  fontSize: 14,
  fontWeight: 600,
  color: '#1c398e',
  marginBottom: '7px',
  lineHeight: '21px',
}));

const InfoText = styled(Typography)(() => ({
  fontSize: 12.3,
  color: '#193cb8',
  lineHeight: '17.5px',
  marginBottom: '3.5px',
}));

const StatusBadge = styled(Box)(() => ({
  display: 'inline-block',
  padding: '4px 8px',
  borderRadius: 4,
  fontSize: 12,
  fontWeight: 500,
  textTransform: 'uppercase',
}));

const StatusApproved = styled(StatusBadge)(() => ({
  backgroundColor: '#dcfce7',
  color: '#166534',
}));

const StatusPending = styled(StatusBadge)(() => ({
  backgroundColor: '#fef3c7',
  color: '#92400e',
}));

const StatusRejected = styled(StatusBadge)(() => ({
  backgroundColor: '#fee2e2',
  color: '#991b1b',
}));

// 결과 카드 스타일
const ResultCard = styled(Paper)(() => ({
  backgroundColor: '#ffffff',
  borderRadius: 12.75,
  border: '1px solid rgba(0,0,0,0.01)',
  marginBottom: '21px',
  boxShadow: 'none',
  transition: 'box-shadow 0.2s ease',
  '&:hover': {
    boxShadow: '0px 4px 6px rgba(0, 0, 0, 0.1)',
  },
}));

const ResultCardHeader = styled(Box)(() => ({
  padding: '21px 21px 10.5px 21px',
  borderBottom: '1px solid #e5e7eb',
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
}));

const ResultCardContent = styled(Box)(() => ({
  padding: '21px',
}));

const CardTitle = styled(Typography)(() => ({
  fontSize: '16px',
  fontWeight: 600,
  color: '#101828',
  lineHeight: '24px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const InfoRow = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  marginBottom: '10.5px',
  '&:last-child': {
    marginBottom: 0,
  },
}));

const InfoLabel = styled(Typography)(() => ({
  fontSize: '14px',
  fontWeight: 500,
  color: '#374151',
  minWidth: '100px',
  lineHeight: '20px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const InfoValue = styled(Typography)(() => ({
  fontSize: '14px',
  color: '#101828',
  lineHeight: '20px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

// 타임라인 스타일
const TimelineContainer = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  gap: '14px',
}));

const TimelineItem = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'flex-start',
  gap: '14px',
}));

const TimelineDot = styled(Box)<{ active?: boolean; completed?: boolean }>(({ active, completed }) => ({
  width: '16px',
  height: '16px',
  borderRadius: '50%',
  backgroundColor: completed ? '#10b981' : active ? '#f59e0b' : '#d1d5db',
  flexShrink: 0,
  marginTop: '2px',
}));

const TimelineContent = styled(Box)(() => ({
  flex: 1,
}));

const TimelineTitle = styled(Typography)(() => ({
  fontSize: '14px',
  fontWeight: 500,
  color: '#101828',
  lineHeight: '20px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const TimelineDate = styled(Typography)(() => ({
  fontSize: '12px',
  color: '#6b7280',
  lineHeight: '16px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const TimelineNote = styled(Typography)(() => ({
  fontSize: '12px',
  color: '#f59e0b',
  lineHeight: '16px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
  fontStyle: 'italic',
}));

const ConfirmationSection: React.FC = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [application, setApplication] = useState<HackathonApplication | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [openSnackbar, setOpenSnackbar] = useState(false);

  const handleSearch = async () => {
    if (!searchQuery.trim()) {
      setError('팀명 또는 이메일을 입력해주세요.');
      setOpenSnackbar(true);
      return;
    }

    setLoading(true);
    setError(null);
    setSuccessMessage(null);
    setApplication(null);

    try {
      // 이메일 형식인지 확인 (더 정확한 정규식 사용)
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      const isEmail = emailRegex.test(searchQuery.trim());
      
      let applications;
      if (isEmail) {
        // 이메일로 조회
        applications = await HackathonService.getApplications({ memberName: searchQuery.trim() });
      } else {
        // 팀명으로 조회
        applications = await HackathonService.getApplications({ teamName: searchQuery.trim() });
      }
      
      if (applications && applications.length > 0) {
        setApplication(applications[0]);
        setSuccessMessage('신청 정보를 찾았습니다.');
        setError(null);
      } else {
        setApplication(null);
        setError('해당 정보를 찾을 수 없습니다.');
        setSuccessMessage(null);
      }
    } catch (err: any) {
      console.error('Search error:', err);
      setApplication(null);
      setSuccessMessage(null);
      if (err.response?.status === 400) {
        setError('검색 조건이 올바르지 않습니다.');
      } else if (err.response?.status === 404) {
        setError('해당 정보를 찾을 수 없습니다.');
      } else {
        setError('조회 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
      }
    } finally {
      setLoading(false);
      setOpenSnackbar(true);
    }
  };

  const handleCloseSnackbar = (_event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setOpenSnackbar(false);
  };

  const infoItems = [
    '• 신청 시 등록하신 팀명 또는 이메일로 조회 가능합니다',
    '• 서류 심사 결과는 3월 20일(수)에 개별 통보됩니다',
    '• 문의사항은 ai-hackathon@company.com으로 연락해주세요',
  ];

  // 진행 상황 데이터
  const progressSteps = [
    {
      title: '신청 접수 완료',
      date: '2024년 3월 12일',
      completed: true,
      active: false,
    },
    {
      title: '서류 심사 중',
      date: '3월 20일 결과 발표 예정',
      completed: false,
      active: true,
      note: '3월 20일 결과 발표 예정',
    },
    {
      title: '예선 진행',
      date: '3월 25일 ~ 4월 5일',
      completed: false,
      active: false,
    },
    {
      title: '결선 진행',
      date: '4월 26일 ~ 4월 27일',
      completed: false,
      active: false,
    },
  ];

  return (
    <ConfirmationContainer>
      <ContentContainer>
        <HeaderSection>
          <Typography 
            variant="h2" 
            sx={{ 
              fontSize: '42px', 
              fontWeight: 700, 
              color: '#101828', 
              textAlign: 'center', 
              lineHeight: '42px',
              fontFamily: '"Apple SD Gothic Neo", sans-serif',
            }}
          >
            Q 신청 조회
          </Typography>
        </HeaderSection>

        <SearchCard>
          <CardHeader>
            <SearchIconBox>
              <SearchIcon sx={{ fontSize: 21, color: '#9810fa' }} />
            </SearchIconBox>
            <Typography 
              variant="h4" 
              sx={{ 
                fontSize: '21px', 
                fontWeight: 400, 
                color: '#101828',
                lineHeight: '28px',
                fontFamily: '"Apple SD Gothic Neo", sans-serif',
              }}
            >
              신청 조회
            </Typography>
          </CardHeader>
          <CardContent>
            <SearchForm>
              <FieldLabel>팀명 또는 신청자 이메일</FieldLabel>
              <InputRow>
                <StyledTextField
                  fullWidth
                  placeholder="팀명 또는 이메일을 입력하세요"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  disabled={loading}
                  data-testid="search-input"
                />
                <SearchButton onClick={handleSearch} disabled={loading} data-testid="search-button">
                  {loading ? '조회 중...' : '조회하기'}
                </SearchButton>
              </InputRow>
            </SearchForm>
          </CardContent>
        </SearchCard>

        {application && (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: '21px' }}>
            {/* 1. 신청 정보 카드 */}
            <ResultCard>
              <ResultCardHeader>
                <CardTitle>신청 정보</CardTitle>
                {application.status === 'PENDING' && <StatusPending>서류 심사 중</StatusPending>}
                {application.status === 'APPROVED' && <StatusApproved>승인</StatusApproved>}
                {application.status === 'REJECTED' && <StatusRejected>반려</StatusRejected>}
              </ResultCardHeader>
              <ResultCardContent>
                <InfoRow>
                  <InfoLabel>신청 번호:</InfoLabel>
                  <InfoValue>HACK2024-{application.id?.toString().padStart(3, '0') || '001'}</InfoValue>
                </InfoRow>
                <InfoRow>
                  <InfoLabel>신청일:</InfoLabel>
                  <InfoValue>
                    {application.firstCreateDatetime 
                      ? new Date(application.firstCreateDatetime).toLocaleDateString('ko-KR', {
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric'
                        })
                      : '2024년 3월 12일'
                    }
                  </InfoValue>
                </InfoRow>
                <InfoRow>
                  <InfoLabel>팀명:</InfoLabel>
                  <InfoValue>{application.team?.teamName || '혁신 AI 팀'}</InfoValue>
                </InfoRow>
                <InfoRow>
                  <InfoLabel>팀 리더:</InfoLabel>
                  <InfoValue>
                    {application.team?.members?.find(m => m.isLeader)?.name || '김개발'}
                  </InfoValue>
                </InfoRow>
                {application.team?.teamSize && (
                  <InfoRow>
                    <InfoLabel>팀 구성:</InfoLabel>
                    <InfoValue>{application.team.teamSize}명</InfoValue>
                  </InfoRow>
                )}
                {application.team?.teamDescription && (
                  <InfoRow>
                    <InfoLabel>팀 설명:</InfoLabel>
                    <InfoValue>{application.team.teamDescription}</InfoValue>
                  </InfoRow>
                )}
              </ResultCardContent>
            </ResultCard>

            {/* 2. 팀원 정보 카드 */}
            <ResultCard>
              <ResultCardHeader>
                <CardTitle>팀원 정보</CardTitle>
              </ResultCardHeader>
              <ResultCardContent>
                                 {application.team?.members?.map((member, index) => (
                   <Box key={index} sx={{ mb: index < (application.team?.members?.length || 0) - 1 ? 2 : 0 }}>
                     <InfoRow>
                       <InfoLabel>
                         {member.isLeader ? `${member.name} (팀 리더)` : member.name}:
                       </InfoLabel>
                       <InfoValue>
                         {member.department || '개발본부'}, {member.email}
                       </InfoValue>
                     </InfoRow>
                   </Box>
                 )) || (
                   <>
                     <InfoRow>
                       <InfoLabel>김개발 (팀 리더):</InfoLabel>
                       <InfoValue>개발본부, kim@company.com</InfoValue>
                     </InfoRow>
                     <InfoRow>
                       <InfoLabel>이기획:</InfoLabel>
                       <InfoValue>상품기획팀, lee@company.com</InfoValue>
                     </InfoRow>
                     <InfoRow>
                       <InfoLabel>박디자인:</InfoLabel>
                       <InfoValue>UX팀, park@company.com</InfoValue>
                     </InfoRow>
                   </>
                 )}
              </ResultCardContent>
            </ResultCard>

            {/* 3. 아이디어 정보 카드 */}
            <ResultCard>
              <ResultCardHeader>
                <CardTitle>아이디어 정보</CardTitle>
              </ResultCardHeader>
              <ResultCardContent>
                <InfoRow>
                  <InfoLabel>아이디어 제목:</InfoLabel>
                  <InfoValue>{application.ideaTitle || '일상 대화 AI 어시스턴트'}</InfoValue>
                </InfoRow>
                                 <InfoRow>
                   <InfoLabel>해결하고자 하는 문제:</InfoLabel>
                   <InfoValue>
                     {application.problemStatement || application.ideaDescription || '업무 중 발생하는 반복적인 질문들을 AI가 자동으로 답변해주는 시스템이 필요합니다.'}
                   </InfoValue>
                 </InfoRow>
                 <InfoRow>
                   <InfoLabel>기술 스택:</InfoLabel>
                   <InfoValue>{application.techStack || 'Python, OpenAI GPT, React, Node.js'}</InfoValue>
                 </InfoRow>
              </ResultCardContent>
            </ResultCard>

            {/* 4. 진행 상황 카드 */}
            <ResultCard>
              <ResultCardHeader>
                <CardTitle>진행 상황</CardTitle>
              </ResultCardHeader>
              <ResultCardContent>
                <TimelineContainer>
                  {progressSteps.map((step, index) => (
                    <TimelineItem key={index}>
                      <TimelineDot completed={step.completed} active={step.active} />
                      <TimelineContent>
                        <TimelineTitle>{step.title}</TimelineTitle>
                        <TimelineDate>{step.date}</TimelineDate>
                        {step.note && <TimelineNote>{step.note}</TimelineNote>}
                      </TimelineContent>
                    </TimelineItem>
                  ))}
                </TimelineContainer>
              </ResultCardContent>
            </ResultCard>

                         {/* 하단 버튼들 */}
             <Box sx={{ display: 'flex', gap: '14px', mt: 2 }}>
               <Button
                 variant="outlined"
                 onClick={() => {
                   // RegistrationSection으로 이동하여 수정 모드로 전환
                   window.location.href = '/registration?edit=true&id=' + application.id;
                 }}
                 sx={{
                   flex: 1,
                   borderColor: '#d1d5db',
                   color: '#374151',
                   textTransform: 'none',
                   fontSize: '14px',
                   fontWeight: 500,
                   py: 1.5,
                   '&:hover': {
                     borderColor: '#9ca3af',
                     backgroundColor: '#f9fafb',
                   },
                 }}
               >
                 정보 수정하기
               </Button>
             </Box>
          </Box>
        )}

        {error && (
          <Alert severity="error" sx={{ mt: 2, mb: 3 }} data-testid="error-message">
            해당 정보를 찾을 수 없습니다.
          </Alert>
        )}

        {successMessage && (
          <Alert severity="success" sx={{ mt: 2, mb: 3 }} data-testid="success-message">
            {successMessage}
          </Alert>
        )}

        <InfoCard>
          <InfoTitle>
            신청 조회 안내
          </InfoTitle>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: '3.5px' }}>
            {infoItems.map((item, index) => (
              <InfoText key={index}>
                {item}
              </InfoText>
            ))}
          </Box>
        </InfoCard>
      </ContentContainer>
      <Snackbar open={openSnackbar} autoHideDuration={6000} onClose={handleCloseSnackbar}>
        <Alert onClose={handleCloseSnackbar} severity={error ? "error" : "success"} sx={{ width: '100%' }}>
          {error || successMessage || '조회가 완료되었습니다.'}
        </Alert>
      </Snackbar>
    </ConfirmationContainer>
  );
};

export default ConfirmationSection; 


================================================
FILE: frontend/src/components/IntroSection.tsx
================================================
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { styled } from '@mui/material/styles';
import { Bot } from 'lucide-react';

const IntroContainer = styled(Box)(() => ({
  background: 'linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%)',
  minHeight: '100vh',
  width: '100%',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  padding: '70px 400px 60.25px 400px',
}));

const ContentContainer = styled(Box)(() => ({
  width: '100%',
  maxWidth: '1120px',
  padding: '70px 21px',
  margin: '0 auto',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '70px',
}));

const HeroSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '28px',
  width: '100%',
}));

const LogoContainer = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  gap: '14px',
  marginBottom: '28px',
}));

const LogoCircle = styled(Box)(() => ({
  width: '56px',
  height: '56px',
  backgroundColor: '#ffffff',
  borderRadius: '50%',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  fontSize: '26.3px',
  fontWeight: 400,
  color: '#0f172a',
}));

const PurpleDot = styled(Box)(() => ({
  width: '28px',
  height: '28px',
  backgroundColor: '#c27aff',
  borderRadius: '50%',
}));

const TitleSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  textAlign: 'center',
  marginBottom: '28px',
}));

const MainTitle = styled(Typography)(() => ({
  fontSize: '63px',
  fontWeight: 700,
  color: '#ffffff',
  lineHeight: '78.75px',
  textAlign: 'center',
  marginBottom: '28px',
  '@media (max-width: 768px)': {
    fontSize: '48px',
  },
}));

const SubTitle = styled(Typography)(() => ({
  fontSize: '17.5px',
  color: '#d1d5dc',
  textAlign: 'center',
  maxWidth: '588px',
  lineHeight: '24.5px',
  marginBottom: '28px',
}));

const ParticipateButton = styled(Button)(() => ({
  backgroundColor: '#9810fa',
  color: '#ffffff',
  fontSize: '15.8px',
  fontWeight: 500,
  padding: '14px 28px',
  borderRadius: '50px',
  textTransform: 'none',
  lineHeight: '24.5px',
}));

const InfoCardsContainer = styled(Box)(() => ({
  display: 'flex',
  gap: '28px',
  width: '100%',
  maxWidth: '1120px',
  marginBottom: '70px',
  '@media (max-width: 768px)': {
    flexDirection: 'column',
  },
}));

const InfoCard = styled(Box)(() => ({
  flex: 1,
  backgroundColor: 'rgba(255, 255, 255, 0.1)',
  borderRadius: '14px',
  padding: '29px',
  border: '1px solid rgba(255, 255, 255, 0.04)',
  backdropFilter: 'blur(10px)',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-start',
  textAlign: 'left',
  gap: '14px',
  position: 'relative',
}));

const CardTitle = styled(Typography)(() => ({
  fontSize: '21px',
  fontWeight: 700,
  color: '#ffffff',
  lineHeight: '28px',
}));

const CardDescription = styled(Typography)(() => ({
  fontSize: '14px',
  color: '#d1d5dc',
  lineHeight: '22.75px',
}));

const ScheduleSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '28px',
  width: '100%',
  maxWidth: '1120px',
  backgroundColor: 'rgba(255, 255, 255, 0.05)',
  borderRadius: '14px',
  padding: '15px 29px 29px 29px',
  border: '1px solid rgba(255, 255, 255, 0.01)',
  backdropFilter: 'blur(10px)',
  position: 'relative',
  '&::before': {
    content: '""',
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    border: '1px solid rgba(255, 255, 255, 0.01)',
    borderRadius: '14px',
    pointerEvents: 'none',
  },
}));

const ScheduleTitle = styled(Typography)(() => ({
  fontSize: '26.3px',
  fontWeight: 700,
  color: '#ffffff',
  textAlign: 'center',
  lineHeight: '31.5px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const ScheduleGrid = styled(Box)(() => ({
  display: 'flex',
  gap: '21px',
  width: '100%',
  '@media (max-width: 768px)': {
    flexDirection: 'column',
  },
}));

const ScheduleCard = styled(Box)(() => ({
  flex: 1,
  display: 'flex',
  flexDirection: 'column',
  gap: '10.5px',
}));

const ScheduleButton = styled(Box)(() => ({
  backgroundColor: '#9810fa',
  borderRadius: '8.75px',
  padding: '10.5px 14px',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '10.5px',
  width: '100%',
  '&.inactive': {
    backgroundColor: '#314158',
  },
}));

const ScheduleText = styled(Typography)(() => ({
  fontSize: '14px',
  fontWeight: 700,
  color: '#ffffff',
  textAlign: 'center',
  lineHeight: '21px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const ScheduleDate = styled(Typography)(() => ({
  fontSize: '12.3px',
  color: '#ffffff',
  textAlign: 'center',
  lineHeight: '17.5px',
  fontFamily: '"SF Pro Text", sans-serif',
}));

const ScheduleDescription = styled(Typography)(() => ({
  fontSize: '12.3px',
  color: '#d1d5dc',
  textAlign: 'center',
  lineHeight: '17.5px',
  fontFamily: '"Apple SD Gothic Neo", sans-serif',
}));

const IntroSection: React.FC = () => {
  const handleParticipateClick = () => {
    const element = document.getElementById('registration');
    if (element) {
      const navHeight = 70;
      const elementPosition = element.offsetTop - navHeight;
      window.scrollTo({
        top: elementPosition,
        behavior: 'smooth'
      });
    }
  };

  return (
    <IntroContainer>
      <ContentContainer>
        <HeroSection>
          <LogoContainer>
            <LogoCircle>
              <Bot size={32} />
            </LogoCircle>
            <PurpleDot />
          </LogoContainer>
          
          <TitleSection>
            <MainTitle>
              Ready for your next
              <br />
              <span style={{ 
                background: 'linear-gradient(135deg, #c27aff 0%, #fb64b6 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                backgroundClip: 'text'
              }}>
                AI Hackathon?
              </span>
            </MainTitle>
            <SubTitle>
              AI Coding 으로 혁신적인 솔루션을 만들어보세요.
              <br />
              창의적인 아이디어와 기술력을 겨루는 특별한 기회입니다.
            </SubTitle>
            <ParticipateButton variant="contained" onClick={handleParticipateClick}>
              참가 신청하기
            </ParticipateButton>
          </TitleSection>

          <InfoCardsContainer>
            <InfoCard>
              <CardTitle>대회 목적</CardTitle>
              <CardDescription>
                사내 개발자들의 AI Coding 역량강화를 통해 
                차세대 개발방법론의 기반을 마련합니다.
              </CardDescription>
            </InfoCard>
            
            <InfoCard>
              <CardTitle>대회 주제</CardTitle>
              <CardDescription>
                "일상을 바꾸는 AI" - 생활 속에서 실제로 활용할 수 있는 
                AI 기반 솔루션을 개발하여 사용자 경험을 혁신해보세요.
              </CardDescription>
            </InfoCard>
            
            <InfoCard>
              <CardTitle>주최 및 주관</CardTitle>
              <CardDescription>
                <strong>주최:</strong> KT<br />
                <strong>주관:</strong> 개발본부<br />
                <strong>후원:</strong> CTO Office
              </CardDescription>
            </InfoCard>
          </InfoCardsContainer>

          <ScheduleSection>
            <ScheduleTitle>대회 일정</ScheduleTitle>
            <ScheduleGrid>
              <ScheduleCard>
                <ScheduleButton>
                  <ScheduleText>참가 신청</ScheduleText>
                  <ScheduleDate>~ 3/15(금)</ScheduleDate>
                </ScheduleButton>
                <ScheduleDescription>
                  AI Coding에 관심이 있는 누구나
                </ScheduleDescription>
              </ScheduleCard>
              
              <ScheduleCard>
                <ScheduleButton className="inactive">
                  <ScheduleText>서류 발표</ScheduleText>
                  <ScheduleDate>3/18(월) ~ 3/20(수)</ScheduleDate>
                </ScheduleButton>
                <ScheduleDescription>
                  100팀 선발
                </ScheduleDescription>
              </ScheduleCard>
              
              <ScheduleCard>
                <ScheduleButton className="inactive">
                  <ScheduleText>예선</ScheduleText>
                  <ScheduleDate>3/25(월) ~ 4/5(금)</ScheduleDate>
                </ScheduleButton>
                <ScheduleDescription>
                  100팀 진행<br />
                  AI Coding을 통한 온라인 예선
                </ScheduleDescription>
              </ScheduleCard>
              
              <ScheduleCard>
                <ScheduleButton className="inactive">
                  <ScheduleText>결선(온라인)</ScheduleText>
                  <ScheduleDate>4/8(월) ~ 4/12(금)</ScheduleDate>
                </ScheduleButton>
                <ScheduleDescription>
                  상위 30팀 진출<br />
                  AI Coding을 통한 온라인 결선
                </ScheduleDescription>
              </ScheduleCard>
              
              <ScheduleCard>
                <ScheduleButton>
                  <ScheduleText>결선(오프라인)</ScheduleText>
                  <ScheduleDate>4/26(금) ~ 4/27(토)</ScheduleDate>
                </ScheduleButton>
                <ScheduleDescription>
                  KT 판교빌딩에서<br />
                  1박 2일 오프라인 결선
                </ScheduleDescription>
              </ScheduleCard>
            </ScheduleGrid>
          </ScheduleSection>
        </HeroSection>
      </ContentContainer>
    </IntroContainer>
  );
};

export default IntroSection; 


================================================
FILE: frontend/src/components/Navigation.tsx
================================================
import React, { useState, useEffect } from 'react';
import { AppBar, Toolbar, Box, Typography, Button } from '@mui/material';
import { styled } from '@mui/material/styles';

const StyledAppBar = styled(AppBar)(() => ({
  backgroundColor: '#0f172b',
  borderBottom: '1px solid #314158',
  position: 'fixed',
  top: 0,
  left: 0,
  right: 0,
  zIndex: 1000,
  padding: '0 80px',
  paddingBottom: '1px',
  paddingTop: '0px',
  borderRadius: 0,
}));

const StyledToolbar = styled(Toolbar)(() => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  padding: '0',
  maxWidth: '1920px',
  margin: '0 auto',
  width: '100%',
  height: '70px',
  gap: '120px',
}));

const LogoContainer = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  gap: '14px',
}));

const LogoBox = styled(Box)(() => ({
  width: '28px',
  height: '28px',
  backgroundColor: '#9810fa',
  borderRadius: '8.75px',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  color: '#ffffff',
  fontSize: '14px',
  fontWeight: 700,
  cursor: 'pointer',
}));

const BrandText = styled(Typography)(() => ({
  color: '#ffffff',
  fontWeight: 700,
  fontSize: '17.5px',
  lineHeight: '24.5px',
}));

const NavLinks = styled(Box)(() => ({
  display: 'flex',
  gap: '28px',
  alignItems: 'center',
}));

const NavButton = styled(Button, {
  shouldForwardProp: (prop) => prop !== 'active'
})<{ active?: boolean }>(({ active }) => ({
  backgroundColor: active ? '#9810fa' : 'transparent',
  color: active ? '#ffffff' : '#d1d5dc',
  fontSize: '14px',
  fontWeight: 400,
  padding: '7px 14px',
  borderRadius: '8.75px',
  textTransform: 'none',
  minWidth: 'auto',
  '&:hover': {
    backgroundColor: active ? '#9810fa' : 'rgba(255, 255, 255, 0.1)',
  },
}));

const ParticipateText = styled(Typography)(() => ({
  color: '#ffffff',
  fontSize: '12.3px',
  fontWeight: 400,
  cursor: 'pointer',
  transition: 'color 0.2s ease',
  padding: '1.75px 0 1.25px 0',
  lineHeight: '1.2',
  '&:hover': {
    color: '#ffffff',
  },
}));

const Navigation: React.FC = () => {
  const [activeSection, setActiveSection] = useState('intro');

  const scrollToSection = (sectionId: string) => {
    const element = document.getElementById(sectionId);
    if (element) {
      const navHeight = 70;
      const elementPosition = element.offsetTop - navHeight;
      window.scrollTo({
        top: elementPosition,
        behavior: 'smooth'
      });
      setActiveSection(sectionId);
    }
  };

  const handleLogoClick = () => {
    scrollToSection('intro');
  };

  const handleParticipateClick = () => {
    scrollToSection('registration');
  };

  // 스크롤 위치에 따라 활성 섹션 감지
  useEffect(() => {
    const handleScroll = () => {
      const sections = ['intro', 'participation', 'registration', 'confirmation'];
      const scrollPosition = window.scrollY + 100;

      for (const sectionId of sections) {
        const element = document.getElementById(sectionId);
        if (element) {
          const { offsetTop, offsetHeight } = element;
          if (scrollPosition >= offsetTop && scrollPosition < offsetTop + offsetHeight) {
            setActiveSection(sectionId);
            break;
          }
        }
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <StyledAppBar elevation={0}>
      <StyledToolbar>
        <LogoContainer>
          <LogoBox onClick={handleLogoClick}>AI</LogoBox>
          <BrandText>
            AI Hackathon
          </BrandText>
        </LogoContainer>

        <NavLinks>
          <NavButton 
            active={activeSection === 'intro'}
            onClick={() => scrollToSection('intro')}
          >
            대회 소개
          </NavButton>
          <NavButton 
            active={activeSection === 'participation'}
            onClick={() => scrollToSection('participation')}
          >
            참가 안내
          </NavButton>
          <NavButton 
            active={activeSection === 'registration'}
            onClick={() => scrollToSection('registration')}
            data-testid="registration-section"
          >
            신청 및 접수
          </NavButton>
          <NavButton 
            active={activeSection === 'confirmation'}
            onClick={() => scrollToSection('confirmation')}
            data-testid="confirmation-section"
          >
            신청 확인
          </NavButton>
        </NavLinks>

        <ParticipateText onClick={handleParticipateClick}>
          지금 참여하세요 →
        </ParticipateText>
      </StyledToolbar>
    </StyledAppBar>
  );
};

export default Navigation; 


================================================
FILE: frontend/src/components/ParticipationSection.tsx
================================================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import { styled } from '@mui/material/styles';
import { CheckCircle, Users, FileText, Calendar } from 'lucide-react';

const ParticipationContainer = styled(Box)(() => ({
  backgroundColor: '#f9fafb',
  padding: '70px 400px',
  width: '100%',
}));

const ContentContainer = styled(Box)(() => ({
  maxWidth: '1120px',
  padding: '0 21px',
  margin: '0 auto',
  display: 'flex',
  flexDirection: 'column',
  gap: '56px',
}));

const HeaderSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '21px',
  textAlign: 'center',
}));

const SectionTitle = styled(Typography)(() => ({
  fontSize: '42px',
  fontWeight: 700,
  color: '#101828',
  textAlign: 'center',
  lineHeight: '42px',
}));

const SectionSubtitle = styled(Typography)(() => ({
  fontSize: '17.5px',
  color: '#4a5565',
  textAlign: 'center',
  maxWidth: '588px',
  lineHeight: '24.5px',
}));

const InfoGrid = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  gap: '42px',
  width: '100%',
}));

const InfoRow = styled(Box)(() => ({
  display: 'flex',
  gap: '42px',
  width: '100%',
  '@media (max-width: 768px)': {
    flexDirection: 'column',
  },
}));

const InfoCard = styled(Paper)(() => ({
  flex: 1,
  backgroundColor: '#ffffff',
  borderRadius: '14px',
  padding: '29px',
  boxShadow: '0px 10px 15px -3px rgba(0,0,0,0.1), 0px 4px 6px -4px rgba(0,0,0,0.1)',
  border: '1px solid #e5e7eb',
  display: 'flex',
  flexDirection: 'column',
  gap: '21px',
  position: 'relative',
}));

const CardHeader = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  gap: '10.5px',
}));

const IconCircle = styled(Box)(() => ({
  width: '28px',
  height: '28px',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  color: '#9810fa',
  fontSize: '14px',
  fontWeight: 700,
}));

const CardTitle = styled(Typography)(() => ({
  fontSize: '21px',
  fontWeight: 700,
  color: '#101828',
  lineHeight: '28px',
}));

const CardContent = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  gap: '14px',
}));

const InfoItem = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'flex-start',
  gap: '10.5px',
}));

const CheckIcon = styled(Box)(() => ({
  width: '7px',
  height: '7px',
  backgroundColor: '#9810fa',
  borderRadius: '50%',
  marginTop: '7px',
  flexShrink: 0,
}));

const InfoText = styled(Typography)(() => ({
  fontSize: '14px',
  color: '#364153',
  lineHeight: '21px',
}));

const NumberedItem = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'flex-start',
  gap: '14px',
}));

const NumberCircle = styled(Box)(() => ({
  width: '24px',
  height: '24px',
  backgroundColor: '#9810fa',
  borderRadius: '50%',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  fontSize: '12px',
  color: '#ffffff',
  fontWeight: 700,
  flexShrink: 0,
  fontFamily: '"SF Pro Text", sans-serif',
  marginTop: '2px',
}));

const ColorDot = styled(Box)<{ color: string }>(({ color }) => ({
  width: '7px',
  height: '7px',
  backgroundColor: color,
  borderRadius: '50%',
  marginTop: '7px',
  flexShrink: 0,
}));

const StepContent = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  gap: '3.5px',
}));

const StepTitle = styled(Typography)(() => ({
  fontSize: '14px',
  fontWeight: 700,
  color: '#101828',
  lineHeight: '21px',
}));

const StepDescription = styled(Typography)(() => ({
  fontSize: '12.3px',
  color: '#4a5565',
  lineHeight: '17.5px',
}));

const ParticipationSection: React.FC = () => {
  return (
    <ParticipationContainer>
      <ContentContainer>
        <HeaderSection>
          <SectionTitle>참가 안내</SectionTitle>
          <SectionSubtitle>
            AI 해커톤 참가를 위한 자세한 안내사항을 확인하세요
          </SectionSubtitle>
        </HeaderSection>

        <InfoGrid>
          <InfoRow>
            <InfoCard>
              <CardHeader>
                <IconCircle>
                  <CheckCircle size={24} />
                </IconCircle>
                <CardTitle>참가 자격</CardTitle>
              </CardHeader>
              <CardContent>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>사내 임직원 누구나 (정규직, 계약직, 인턴 포함)</InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>AI Coding에 관심이 있는 모든 직군</InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>프로그래밍 경험이 있거나 학습 의지가 있는 자</InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>전체 일정에 성실히 참여 가능한 자</InfoText>
                </InfoItem>
              </CardContent>
            </InfoCard>

            <InfoCard>
              <CardHeader>
                <IconCircle>
                  <Users size={24} />
                </IconCircle>
                <CardTitle>팀 구성</CardTitle>
              </CardHeader>
              <CardContent>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>
                    <strong>팀 규모:</strong> 1~4명 (개인 참가 가능)
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>
                    <strong>팀 구성:</strong> 자유롭게 팀 구성 또는 개인 참가
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>
                    <strong>팀 리더:</strong> 팀당 1명 지정 (대표 연락처)
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <CheckIcon />
                  <InfoText>
                    <strong>권장 구성:</strong> 개발자 + 기획자 + 디자이너
                  </InfoText>
                </InfoItem>
              </CardContent>
            </InfoCard>
          </InfoRow>

          <InfoRow>
            <InfoCard>
              <CardHeader>
                <IconCircle>
                  <FileText size={24} />
                </IconCircle>
                <CardTitle>신청 방법</CardTitle>
              </CardHeader>
              <CardContent>
                <NumberedItem>
                  <NumberCircle>1</NumberCircle>
                  <StepContent>
                    <StepTitle>온라인 신청서 작성</StepTitle>
                    <StepDescription>팀 정보 및 참가자 정보 입력</StepDescription>
                  </StepContent>
                </NumberedItem>
                <NumberedItem>
                  <NumberCircle>2</NumberCircle>
                  <StepContent>
                    <StepTitle>아이디어 개요 제출</StepTitle>
                    <StepDescription>해결하고 싶은 문제와 접근 방법 간략히 기술</StepDescription>
                  </StepContent>
                </NumberedItem>
                <NumberedItem>
                  <NumberCircle>3</NumberCircle>
                  <StepContent>
                    <StepTitle>서약서 제출</StepTitle>
                    <StepDescription>개인정보 활용 동의 및 참가 규정 동의</StepDescription>
                  </StepContent>
                </NumberedItem>
              </CardContent>
            </InfoCard>

            <InfoCard>
              <CardHeader>
                <IconCircle>
                  <Calendar size={24} />
                </IconCircle>
                <CardTitle>주요 안내사항</CardTitle>
              </CardHeader>
              <CardContent>
                <InfoItem>
                  <ColorDot color="#fb2c36" />
                  <InfoText>
                    <strong>신청 마감:</strong> 2025년 3월 15일 (금) 18:00
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <ColorDot color="#ff6900" />
                  <InfoText>
                    <strong>선발 인원:</strong> 총 100팀 (선착순 아님, 서류 심사)
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <ColorDot color="#00c950" />
                  <InfoText>
                    <strong>제공 사항:</strong> 개발 환경, 멘토링, 식사, 기념품
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <ColorDot color="#2b7fff" />
                  <InfoText>
                    <strong>시상:</strong> 대상 1팀 (500만원), 우수상 2팀 (각 200만원)
                  </InfoText>
                </InfoItem>
                <InfoItem>
                  <ColorDot color="#ad46ff" />
                  <InfoText>
                    <strong>문의:</strong> ai-hackathon@company.com
                  </InfoText>
                </InfoItem>
              </CardContent>
            </InfoCard>
          </InfoRow>
        </InfoGrid>
      </ContentContainer>
    </ParticipationContainer>
  );
};

export default ParticipationSection; 


================================================
FILE: frontend/src/components/RegistrationSection.tsx
================================================
import React, { useState } from 'react';
import { Box, Typography, Paper, TextField, Button, IconButton, Alert, Snackbar, MenuItem } from '@mui/material';
import { styled } from '@mui/material/styles';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import type { TeamMember, CreateApplicationRequest } from '../model/types';
import { HackathonService } from '../services/HackathonService';
import type { HackathonApplication } from '../model/types';

const RegistrationContainer = styled(Box)(() => ({
  padding: '70px 568px',
  minHeight: 1200,
  background: 'linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%)',
}));

const ContentContainer = styled(Box)(() => ({
  maxWidth: 784,
  margin: '0 auto',
  padding: '0 21px',
}));

const HeaderSection = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  gap: '21px',
  marginBottom: '42px',
}));

const SectionTitle = styled(Typography)(() => ({
  fontSize: '42px',
  fontWeight: 700,
  color: '#101828',
  textAlign: 'center',
  lineHeight: '42px',
}));

const SectionSubtitle = styled(Typography)(() => ({
  fontSize: '17.5px',
  color: '#4a5565',
  textAlign: 'center',
  maxWidth: '588px',
  lineHeight: '24.5px',
}));

const FormCard = styled(Paper)(() => ({
  marginBottom: '28px',
}));

const CardHeader = styled(Box)(() => ({
  padding: '16px 16px 8px 16px',
  borderBottom: 'none',
}));

const CardTitle = styled(Typography)(() => ({
  fontSize: '21px',
  fontWeight: 400,
  color: '#101828',
  lineHeight: '28px',
}));

const CardContent = styled(Box)(() => ({
  padding: '0 16px 16px 16px',
  display: 'flex',
  flexDirection: 'column',
  gap: '16px',
}));

const FormField = styled(Box)(() => ({
  marginBottom: '0',
  '&.half-width': {
    flex: '0 0 calc(50% - 8px)',
  },
}));

const FormRow = styled(Box)(() => ({
  display: 'flex',
  gap: '16px',
  width: '100%',
  '@media (max-width: 768px)': {
    flexDirection: 'column',
  },
}));

const FieldLabel = styled(Typography)(() => ({
  fontSize: '13px',
  fontWeight: 500,
  color: '#111827',
  marginBottom: '4px',
  lineHeight: '18px',
}));

const StyledTextField = styled(TextField)(() => ({
  width: '100%', // 전체 넓이 사용
  '& .MuiOutlinedInput-root': {
    backgroundColor: '#f9fafb',
    borderRadius: '6px',
    width: '100%', // 전체 넓이 사용
    '& fieldset': {
      border: 'none',
    },
    '& input': {
      fontSize: '14px',
      padding: '4px 6px',
      color: '#374151',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
      lineHeight: '1.4',
      height: '32px',
      minHeight: '32px',
      width: '100%', // 전체 넓이 사용
    },
    '& .MuiOutlinedInput-root:not(.MuiInputBase-multiline)': {
      height: '32px',
      minHeight: '32px',
    },
    '& .MuiOutlinedInput-root.MuiInputBase-multiline': {
      minHeight: '48px',
      maxHeight: '48px',
      alignItems: 'flex-start',
      padding: '0px',
      '& .MuiInputBase-input': {
        padding: '2px 4px',
      },
    },
    '& input::placeholder': {
      color: '#6b7280',
      opacity: 1,
      fontSize: '14px',
    },
    '& textarea': {
      fontSize: '14px',
      padding: '2px 4px',
      color: '#374151',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
      lineHeight: '1.4',
      minHeight: '48px',
      maxHeight: '48px',
      resize: 'none',
    },
    '& textarea::placeholder': {
      color: '#6b7280',
      opacity: 1,
      fontSize: '14px',
      lineHeight: '1.5',
    },
    '&:hover': {
      backgroundColor: '#e2e8f0',
    },
    '&.Mui-focused': {
      backgroundColor: '#ffffff',
      border: '1px solid #9810fa',
    },
  },
  '& .MuiInputLabel-root': {
    fontSize: '14px',
    color: '#6b7280',
  },
  '& .MuiInputBase-input::placeholder': {
    color: '#6b7280',
    opacity: 1,
    fontSize: '14px',
  },
  '& .MuiInputBase-input[data-multiline="true"]::placeholder': {
    color: '#6b7280',
    opacity: 1,
    fontSize: '14px',
    lineHeight: '1.5',
    paddingTop: '0',
    paddingBottom: '0',
  },
  '& .MuiInputBase-input': {
    padding: '4px 6px',
    boxSizing: 'border-box',
    width: '100%', // 전체 넓이 사용
  },
  '& .MuiInputBase-input:not(textarea)': {
    height: '32px',
    minHeight: '32px',
  },

  '& .MuiFormHelperText-root': {
    fontSize: '11px',
    color: '#6b7280',
    marginLeft: '0',
    marginTop: '2px',
    textAlign: 'left',
  },
  '&.multiline': {
    '& .MuiOutlinedInput-root': {
      alignItems: 'flex-start',
    },
  },
}));

const AddMemberButton = styled(Button)(() => ({
  backgroundColor: '#ffffff',
  color: '#0a0a0a',
  fontSize: '12.3px',
  fontWeight: 500,
  padding: '1px 9.75px',
  borderRadius: '6.75px',
  border: '1px solid #d1d5db',
  minHeight: '28px',
  textTransform: 'none',
  lineHeight: '17.5px',
  '&:hover': {
    backgroundColor: '#f9fafb',
    border: '1px solid #9ca3af',
  },
  '& .MuiButton-startIcon': {
    marginRight: '5.25px',
  },
}));

const TeamMemberCard = styled(Paper)(() => ({
  backgroundColor: '#ffffff',
  borderRadius: '8.75px',
  border: '1px solid #e5e7eb',
  padding: '22px',
  marginBottom: '28px', // 팀원 정보와 팀 리더 간의 간격 증가
  boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.1)',
  transition: 'box-shadow 0.2s ease',
  '&:hover': {
    boxShadow: '0px 4px 6px rgba(0, 0, 0, 0.1)',
  },
}));

const TeamMemberTitle = styled(Typography)(() => ({
  fontSize: '14px',
  fontWeight: 600,
  color: '#101828',
  lineHeight: '21px',
}));

const MemberHeader = styled(Box)(() => ({
  display: 'flex',
  alignItems: 'center',
  marginBottom: '14px',
  paddingBottom: '7px',
  // borderBottom 제거 - 선 없음
}));

const MemberFormContainer = styled(Box)(() => ({
  width: '100%',
  marginTop: '14px', // 팀 리더 제목과 입력 필드 간의 간격
  display: 'flex',
  flexDirection: 'column',
  gap: '20.25px',
}));



const RemoveMemberButton = styled(IconButton)(({ theme }) => ({
  color: '#ef4444',
  padding: theme.spacing(0.5),
  '&:hover': {
    backgroundColor: '#fef2f2',
  },
}));

const SubmitButton = styled(Button)(() => ({
  backgroundColor: '#9810fa',
  color: '#ffffff',
  fontSize: '16px',
  fontWeight: 600,
  padding: '12px 32px',
  borderRadius: '50px',
  textTransform: 'none',
  lineHeight: '24px',
  minHeight: '48px',
  minWidth: '200px',
  boxShadow: '0px 4px 12px rgba(152, 16, 250, 0.3)',
  '&:hover': {
    backgroundColor: '#7c3aed',
    boxShadow: '0px 6px 16px rgba(152, 16, 250, 0.4)',
  },
  '&:disabled': {
    backgroundColor: '#d1d5db',
    color: '#6b7280',
    boxShadow: 'none',
  },
}));

const SubmitNote = styled(Typography)(() => ({
  fontSize: '13px',
  color: '#6b7280',
  textAlign: 'center',
  lineHeight: '18px',
  marginTop: '0px',
}));

const SuccessContainer = styled(Box)(() => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  textAlign: 'center',
  padding: '120px 0 80px 0',
}));

const SuccessIcon = styled(CheckCircleIcon)(() => ({
  fontSize: '64px',
  color: '#10b981',
  marginBottom: '32px',
}));

const SuccessTitle = styled(Typography)(() => ({
  fontSize: '32px',
  fontWeight: 700,
  color: '#101828',
  marginBottom: '16px',
  lineHeight: '40px',
}));

const SuccessMessage = styled(Typography)(() => ({
  fontSize: '16px',
  color: '#6b7280',
  marginBottom: '40px',
  lineHeight: '24px',
  maxWidth: '400px',
}));

const RegistrationSection: React.FC = () => {
  // URL 파라미터 확인
  const urlParams = new URLSearchParams(window.location.search);
  const isEditMode = urlParams.get('edit') === 'true';
  const editId = urlParams.get('id');

  const [teamInfo, setTeamInfo] = useState({
    teamName: '',
    teamSize: '',
    teamDescription: '',
    members: [
      {
        name: '',
        email: '',
        phone: '',
        role: '',
        department: '',
        position: '',
        isLeader: true,
      } as TeamMember,
    ],
  });

  const [ideaInfo, setIdeaInfo] = useState({
    ideaTitle: '',
    ideaDescription: '',
    problemStatement: '',
    solutionApproach: '',
    techStack: '',
  });

  const [isSubmitted, setIsSubmitted] = useState(false);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error'>('success');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState<{[key: string]: string}>({});
  const [existingApplication, setExistingApplication] = useState<HackathonApplication | null>(null);

  // 수정 모드일 때 기존 데이터 불러오기
  React.useEffect(() => {
    if (isEditMode && editId) {
      loadExistingApplicationById(editId);
    }
  }, [isEditMode, editId]);

  // ID로 기존 신청 정보를 불러오는 함수
  const loadExistingApplicationById = async (id: string) => {
    try {
      const application = await HackathonService.getApplication(parseInt(id));
      setExistingApplication(application);
      
      // 팀 정보 설정
      setTeamInfo({
        teamName: application.team?.teamName || '',
        teamSize: application.team?.teamSize || application.team?.members?.length?.toString() || '',
        teamDescription: application.team?.teamDescription || '',
        members: application.team?.members || [
          {
            name: '',
            email: '',
            phone: '',
            role: '',
            department: '',
            position: '',
            isLeader: true,
          } as TeamMember,
        ],
      });

      // 아이디어 정보 설정
      setIdeaInfo({
        ideaTitle: application.ideaTitle || '',
        ideaDescription: application.ideaDescription || '',
        problemStatement: application.problemStatement || '',
        solutionApproach: application.solutionApproach || '',
        techStack: application.techStack || '',
      });

      setSnackbarMessage('기존 신청 정보를 불러왔습니다.');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
    } catch (error) {
      console.error('기존 신청 정보 불러오기 실패:', error);
      setSnackbarMessage('기존 신청 정보를 불러오는데 실패했습니다.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    }
  };

  // 기존 신청 정보를 불러와서 폼에 채우는 함수
  const loadExistingApplication = async () => {
    try {
      let applications: HackathonApplication[] = [];
      
      // 팀 리더의 이메일로 기존 신청 정보 조회
      const leaderEmail = teamInfo.members[0]?.email;
      if (leaderEmail) {
        try {
          console.log('이메일로 기존 신청 정보 조회:', leaderEmail);
          applications = await HackathonService.getApplications({ memberName: leaderEmail });
          console.log('이메일로 조회 결과:', applications.length);
        } catch (error) {
          console.log('이메일로 조회 실패, 팀명으로 시도');
        }
      }
      
      // 이메일로 찾지 못했고, 팀명이 있으면 팀명으로 조회
      if (applications.length === 0 && teamInfo.teamName) {
        try {
          console.log('팀명으로 기존 신청 정보 조회:', teamInfo.teamName);
          applications = await HackathonService.getApplications({ teamName: teamInfo.teamName });
          console.log('팀명으로 조회 결과:', applications.length);
        } catch (error) {
          console.log('팀명으로도 조회 실패');
        }
      }
      
      if (applications && applications.length > 0) {
        const existingApp = applications[0];
        console.log('기존 신청 정보 찾음:', existingApp.id);
        setExistingApplication(existingApp);
        
        // 팀 정보 설정
        setTeamInfo({
          teamName: existingApp.team?.teamName || '',
          teamSize: existingApp.team?.teamSize || existingApp.team?.members?.length?.toString() || '',
          teamDescription: existingApp.team?.teamDescription || '',
          members: existingApp.team?.members || [
            {
              name: '',
              email: '',
              phone: '',
              role: '',
              department: '',
              position: '',
              isLeader: true,
            } as TeamMember,
          ],
        });

        // 아이디어 정보 설정
        setIdeaInfo({
          ideaTitle: existingApp.ideaTitle || '',
          ideaDescription: existingApp.ideaDescription || '',
          problemStatement: existingApp.problemStatement || '',
          solutionApproach: existingApp.solutionApproach || '',
          techStack: existingApp.techStack || '',
        });

        setSnackbarMessage('기존 신청 정보를 불러왔습니다.');
        setSnackbarSeverity('success');
        setSnackbarOpen(true);
      } else {
        console.log('기존 신청 정보를 찾을 수 없음');
        setSnackbarMessage('기존 신청 정보를 찾을 수 없습니다. 새로운 신청으로 진행됩니다.');
        setSnackbarSeverity('success');
        setSnackbarOpen(true);
        // 기존 신청 정보가 없으면 새로 생성할 준비
        setExistingApplication(null);
      }
    } catch (error) {
      console.error('기존 신청 정보 불러오기 실패:', error);
      setSnackbarMessage('기존 신청 정보를 불러올 수 없습니다. 새로운 신청으로 진행됩니다.');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
      setExistingApplication(null);
    }
  };

  const handleEditApplication = () => {
    setIsSubmitted(false);
    // 기존 신청 정보가 있으면 바로 사용, 없으면 조회 시도
    if (existingApplication && existingApplication.id) {
      console.log('기존 신청 정보가 있음, 바로 사용:', existingApplication.id);
      // 기존 신청 정보를 폼에 채우기
      setTeamInfo({
        teamName: existingApplication.team?.teamName || '',
        teamSize: existingApplication.team?.members?.length?.toString() || '',
        teamDescription: existingApplication.team?.teamDescription || '',
        members: existingApplication.team?.members || [
          {
            name: '',
            email: '',
            phone: '',
            role: '',
            department: '',
            position: '',
            isLeader: true,
          } as TeamMember,
        ],
      });

      setIdeaInfo({
        ideaTitle: existingApplication.ideaTitle || '',
        ideaDescription: existingApplication.ideaDescription || '',
        problemStatement: existingApplication.problemStatement || '',
        solutionApproach: existingApplication.solutionApproach || '',
        techStack: existingApplication.techStack || '',
      });
    } else {
      console.log('기존 신청 정보가 없음, 조회 시도');
      // 기존 신청 정보를 불러오기 시도
      loadExistingApplication();
    }
  };

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};

    // 팀명 검증
    if (!teamInfo.teamName.trim()) {
      newErrors.teamName = '팀명을 입력해주세요.';
    }

    // 팀 리더 정보 검증
    if (!teamInfo.members[0]?.name?.trim()) {
      newErrors.leaderName = '팀 리더 이름을 입력해주세요.';
    }
    if (!teamInfo.members[0]?.email?.trim()) {
      newErrors.leaderEmail = '팀 리더 이메일을 입력해주세요.';
    } else if (!/\S+@\S+\.\S+/.test(teamInfo.members[0]?.email || '')) {
      newErrors.leaderEmail = '올바른 이메일 형식을 입력해주세요.';
    }
    if (!teamInfo.members[0]?.department?.trim()) {
      newErrors.leaderDepartment = '팀 리더 소속 부서를 입력해주세요.';
    }

    // 아이디어 정보 검증
    if (!ideaInfo.ideaTitle.trim()) {
      newErrors.ideaTitle = '아이디어 제목을 입력해주세요.';
    } else if (ideaInfo.ideaTitle.length > 300) {
      newErrors.ideaTitle = '아이디어 제목은 300자 이내로 입력해주세요.';
    }
    if (!ideaInfo.problemStatement.trim()) {
      newErrors.problemStatement = '해결하고자 하는 문제를 입력해주세요.';
    } else if (ideaInfo.problemStatement.length > 300) {
      newErrors.problemStatement = '해결하고자 하는 문제는 300자 이내로 입력해주세요.';
    }
    if (!ideaInfo.solutionApproach.trim()) {
      newErrors.solutionApproach = '솔루션 접근 방법을 입력해주세요.';
    } else if (ideaInfo.solutionApproach.length > 500) {
      newErrors.solutionApproach = '솔루션 접근 방법은 500자 이내로 입력해주세요.';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleTeamInfoChange = (field: string, value: string) => {
    setTeamInfo(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleIdeaInfoChange = (field: string, value: string) => {
    setIdeaInfo(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleMemberChange = (index: number, field: string, value: string) => {
    setTeamInfo(prev => ({
      ...prev,
      members: prev.members.map((member, i) =>
        i === index ? { ...member, [field]: value } : member
      ),
    }));
  };

  const addMember = () => {
    if (teamInfo.members.length < 4) {
      setTeamInfo(prev => ({
        ...prev,
        members: [
          ...prev.members,
          {
            name: '',
            email: '',
            phone: '',
            role: '',
            department: '',
            position: '',
            isLeader: false,
          } as TeamMember,
        ],
      }));
    }
  };

  const removeMember = (index: number) => {
    if (teamInfo.members.length > 1) {
      setTeamInfo(prev => ({
        ...prev,
        members: prev.members.filter((_, i) => i !== index),
      }));
    }
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    try {
      // API 요청 데이터 구성
      const requestData: CreateApplicationRequest = {
        teamName: teamInfo.teamName,
        teamSize: teamInfo.teamSize,
        teamDescription: teamInfo.teamDescription,
        ideaTitle: ideaInfo.ideaTitle,
        ideaDescription: ideaInfo.ideaDescription,
        problemStatement: ideaInfo.problemStatement,
        solutionApproach: ideaInfo.solutionApproach,
        techStack: ideaInfo.techStack,
        members: teamInfo.members,
      };

      // 기존 신청 정보가 있으면 업데이트, 없으면 새로 생성
      if (existingApplication && existingApplication.id) {
        console.log('기존 신청 정보 업데이트:', existingApplication.id);
        await HackathonService.updateApplication(existingApplication.id, requestData);
        setSnackbarMessage('신청 정보가 성공적으로 수정되었습니다!');
      } else {
        console.log('새 신청 정보 생성');
        const newApplication = await HackathonService.createApplication(requestData);
        setExistingApplication(newApplication); // 새로 생성된 신청 정보 저장
        setSnackbarMessage('신청이 성공적으로 제출되었습니다!');
      }
      
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
      setIsSubmitted(true);
    } catch (error: any) {
      console.error('Submit error:', error);
      setSnackbarMessage(error.message || '제출 중 오류가 발생했습니다.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCloseSnackbar = (_event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  // 제출 완료 화면
  if (isSubmitted) {
    return (
      <RegistrationContainer>
        <ContentContainer>
          <SuccessContainer>
            <SuccessIcon />
            <SuccessTitle>
              신청이 완료되었습니다!
            </SuccessTitle>
            <SuccessMessage>
              등록해주신 이메일로 확인 메일을 발송했습니다.<br />
              서류 심사 결과는 3월 20일(수)에 개별 안내드립니다.
            </SuccessMessage>
            <SubmitButton onClick={handleEditApplication}>
              정보 수정하기
            </SubmitButton>
          </SuccessContainer>
        </ContentContainer>
      </RegistrationContainer>
    );
  }

  return (
    <RegistrationContainer>
      <ContentContainer>
        <HeaderSection>
          <SectionTitle>
            신청 및 접수
          </SectionTitle>
          <SectionSubtitle>
            AI 해커톤에 참가하시려면 아래 정보를 입력해주세요
          </SectionSubtitle>
        </HeaderSection>

        <FormCard>
          <CardHeader>
            <CardTitle>
              팀 정보
            </CardTitle>
          </CardHeader>
          <CardContent>
            <FormRow>
              <FormField className="half-width">
                <FieldLabel>팀명 *</FieldLabel>
                <StyledTextField
                  fullWidth
                  value={teamInfo.teamName}
                  onChange={(e) => handleTeamInfoChange('teamName', e.target.value)}
                  placeholder="팀명을 입력하세요"
                  error={!!errors.teamName}
                  helperText={errors.teamName}
                  data-testid="team-name-input"
                />
              </FormField>
              <FormField className="half-width">
                <FieldLabel>팀 구성</FieldLabel>
                <StyledTextField
                  fullWidth
                  select
                  value={teamInfo.teamSize || ''}
                  onChange={(e) => handleTeamInfoChange('teamSize', e.target.value)}
                  placeholder="팀 구성을 선택하세요"
                >
                  <MenuItem value="1">개인 (1명)</MenuItem>
                  <MenuItem value="2">2명</MenuItem>
                  <MenuItem value="3">3명</MenuItem>
                  <MenuItem value="4">4명</MenuItem>
                </StyledTextField>
              </FormField>
            </FormRow>
            <FormField>
              <FieldLabel>팀 소개</FieldLabel>
              <StyledTextField
                fullWidth
                multiline
                rows={2}
                value={teamInfo.teamDescription || ''}
                onChange={(e) => handleTeamInfoChange('teamDescription', e.target.value)}
                placeholder="팀을 간단히 소개해주세요"
                className="multiline"
              />
            </FormField>
          </CardContent>
        </FormCard>

        <FormCard>
          <CardHeader>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
              <CardTitle>
                팀원 정보
              </CardTitle>
              <AddMemberButton onClick={addMember} startIcon={<AddIcon />}>
                팀원 추가
              </AddMemberButton>
            </Box>
          </CardHeader>
          <CardContent>
            <TeamMemberCard>
              <MemberHeader>
                <TeamMemberTitle>
                  팀 리더
                </TeamMemberTitle>
              </MemberHeader>
              <MemberFormContainer>
                <FormRow>
                  <FormField className="half-width">
                    <FieldLabel>이름 *</FieldLabel>
                    <StyledTextField
                      fullWidth
                      value={teamInfo.members[0]?.name || ''}
                      onChange={(e) => handleMemberChange(0, 'name', e.target.value)}
                      placeholder="이름을 입력하세요"
                      error={!!errors.leaderName}
                      helperText={errors.leaderName}
                      data-testid="leader-name-input"
                    />
                  </FormField>
                  <FormField className="half-width">
                    <FieldLabel>소속 부서 *</FieldLabel>
                    <StyledTextField
                      fullWidth
                      value={teamInfo.members[0]?.department || ''}
                      onChange={(e) => handleMemberChange(0, 'department', e.target.value)}
                      placeholder="부서명을 입력하세요"
                      error={!!errors.leaderDepartment}
                      helperText={errors.leaderDepartment}
                      data-testid="leader-department-input"
                    />
                  </FormField>
                </FormRow>
                <FormRow>
                  <FormField className="half-width">
                    <FieldLabel>직급/직책</FieldLabel>
                    <StyledTextField
                      fullWidth
                      value={teamInfo.members[0]?.position || ''}
                      onChange={(e) => handleMemberChange(0, 'position', e.target.value)}
                      placeholder="직급 또는 직책을 입력하세요"
                    />
                  </FormField>
                  <FormField className="half-width">
                    <FieldLabel>이메일 *</FieldLabel>
                    <StyledTextField
                      fullWidth
                      value={teamInfo.members[0]?.email || ''}
                      onChange={(e) => handleMemberChange(0, 'email', e.target.value)}
                      placeholder="이메일을 입력하세요"
                      error={!!errors.leaderEmail}
                      helperText={errors.leaderEmail}
                      data-testid="leader-email-input"
                    />
                  </FormField>
                </FormRow>
              </MemberFormContainer>
            </TeamMemberCard>

            {/* Additional Team Members */}
            {teamInfo.members.slice(1).map((member, index) => (
              <TeamMemberCard key={index + 1}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <TeamMemberTitle>
                    팀원 {index + 1}
                  </TeamMemberTitle>
                  <RemoveMemberButton
                    onClick={() => removeMember(index + 1)}
                    size="small"
                  >
                    <DeleteIcon />
                  </RemoveMemberButton>
                </Box>
                <MemberFormContainer>
                  <FormRow>
                    <FormField className="half-width">
                      <FieldLabel>이름 *</FieldLabel>
                      <StyledTextField
                        fullWidth
                        value={member.name}
                        onChange={(e) => handleMemberChange(index + 1, 'name', e.target.value)}
                        placeholder="이름을 입력하세요"
                        error={!!errors[`name${index + 1}`]}
                        helperText={errors[`name${index + 1}`]}
                      />
                    </FormField>
                    <FormField className="half-width">
                      <FieldLabel>소속 부서 *</FieldLabel>
                      <StyledTextField
                        fullWidth
                        value={member.department}
                        onChange={(e) => handleMemberChange(index + 1, 'department', e.target.value)}
                        placeholder="부서명을 입력하세요"
                        error={!!errors[`department${index + 1}`]}
                        helperText={errors[`department${index + 1}`]}
                      />
                    </FormField>
                  </FormRow>
                  <FormRow>
                    <FormField className="half-width">
                      <FieldLabel>직급/직책</FieldLabel>
                      <StyledTextField
                        fullWidth
                        value={member.position}
                        onChange={(e) => handleMemberChange(index + 1, 'position', e.target.value)}
                        placeholder="직급 또는 직책을 입력하세요"
                      />
                    </FormField>
                    <FormField className="half-width">
                      <FieldLabel>이메일 *</FieldLabel>
                      <StyledTextField
                        fullWidth
                        value={member.email}
                        onChange={(e) => handleMemberChange(index + 1, 'email', e.target.value)}
                        placeholder="이메일을 입력하세요"
                        error={!!errors[`email${index + 1}`]}
                        helperText={errors[`email${index + 1}`]}
                      />
                    </FormField>
                  </FormRow>
                </MemberFormContainer>
              </TeamMemberCard>
            ))}
          </CardContent>
        </FormCard>

        {/* 아이디어 정보 */}
        <FormCard>
          <CardHeader>
            <CardTitle>
              아이디어 정보
            </CardTitle>
          </CardHeader>
          <CardContent>
            <FormField>
              <FieldLabel>아이디어 제목 *</FieldLabel>
              <StyledTextField
                fullWidth
                value={ideaInfo.ideaTitle}
                onChange={(e) => handleIdeaInfoChange('ideaTitle', e.target.value)}
                placeholder="아이디어의 제목을 입력하세요 (300자 이내)"
                error={!!errors.ideaTitle}
                helperText={errors.ideaTitle}
                data-testid="idea-title-input"
                inputProps={{
                  maxLength: 300,
                }}
              />
            </FormField>
            <FormField>
              <FieldLabel>해결하고자 하는 문제 *</FieldLabel>
              <StyledTextField
                fullWidth
                multiline
                rows={2}
                value={ideaInfo.problemStatement}
                onChange={(e) => {
                  const value = e.target.value;
                  if (value.length <= 300) {
                    handleIdeaInfoChange('problemStatement', value);
                  }
                }}
                placeholder="어떤 문제를 해결하고 싶으신가요? (300자 이내)"
                error={!!errors.problemStatement}
                helperText={errors.problemStatement}
                data-testid="problem-statement-input"
                className="multiline"
                inputProps={{
                  maxLength: 300,
                }}
              />
            </FormField>
            <FormField>
              <FieldLabel>솔루션 접근 방법 *</FieldLabel>
              <StyledTextField
                fullWidth
                multiline
                rows={2}
                value={ideaInfo.solutionApproach}
                onChange={(e) => {
                  const value = e.target.value;
                  if (value.length <= 500) {
                    handleIdeaInfoChange('solutionApproach', value);
                  }
                }}
                placeholder="어떤 방식으로 해결하실 계획인가요? (500자 이내)"
                error={!!errors.solutionApproach}
                helperText={errors.solutionApproach}
                data-testid="solution-approach-input"
                className="multiline"
                inputProps={{
                  maxLength: 500,
                }}
              />
            </FormField>
            <FormField>
              <FieldLabel>사용 예정 기술스택</FieldLabel>
              <StyledTextField
                fullWidth
                value={ideaInfo.techStack}
                onChange={(e) => handleIdeaInfoChange('techStack', e.target.value)}
                placeholder="예: Python, TensorFlow, React, etc."
                data-testid="tech-stack-input"
                inputProps={{
                  maxLength: 200,
                }}
              />
            </FormField>
          </CardContent>
        </FormCard>

        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '12px', mt: '40px' }}>
          <SubmitButton
            onClick={handleSubmit}
            disabled={isSubmitting}
            data-testid="submit-button"
          >
                          {isSubmitting ? '제출 중...' : (isEditMode ? '정보 수정하기' : '참가 신청하기')}
          </SubmitButton>
          <SubmitNote>
            * 제출 후에도 마감일 전까지 수정이 가능합니다
          </SubmitNote>
        </Box>

        <Snackbar
          open={snackbarOpen}
          autoHideDuration={6000}
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'left' }}
        >
          <Alert 
            onClose={handleCloseSnackbar} 
            severity={snackbarSeverity} 
            sx={{ width: '100%' }}
            data-testid={snackbarSeverity === 'success' ? 'success-message' : 'error-message'}
          >
            {snackbarMessage}
          </Alert>
        </Snackbar>
      </ContentContainer>
    </RegistrationContainer>
  );
};

export default RegistrationSection;


================================================
FILE: frontend/src/components/__tests__/RegistrationSection.test.tsx
================================================
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import RegistrationSection from '../RegistrationSection';
import { HackathonService } from '../../services/HackathonService';

// HackathonService 모킹
jest.mock('../../services/HackathonService', () => ({
  HackathonService: {
    createApplication: jest.fn(),
  },
}));

const mockedHackathonService = HackathonService as jest.Mocked<typeof HackathonService>;

describe('RegistrationSection', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('TC-UNIT-009: RegistrationSection 컴포넌트 렌더링 테스트', () => {
    it('컴포넌트 정상 렌더링', () => {
      // Given & When
      render(<RegistrationSection />);

      // Then
      expect(screen.getByText('신청 및 접수')).toBeInTheDocument();
      expect(screen.getByText('팀 정보')).toBeInTheDocument();
      expect(screen.getByText('팀원 정보')).toBeInTheDocument();
      expect(screen.getByText('아이디어 정보')).toBeInTheDocument();
    });

    it('폼 필드 존재 확인', () => {
      // Given & When
      render(<RegistrationSection />);

      // Then
      expect(screen.getByPlaceholderText(/팀명을 입력하세요/)).toBeInTheDocument();
      expect(screen.getByText('팀 구성')).toBeInTheDocument();
      expect(screen.getByText('팀 소개')).toBeInTheDocument();
      expect(screen.getByText('아이디어 제목 *')).toBeInTheDocument();
      expect(screen.getByText('해결하고자 하는 문제 *')).toBeInTheDocument();
      expect(screen.getByText('솔루션 접근 방법 *')).toBeInTheDocument();
      expect(screen.getByText('사용 예정 기술스택')).toBeInTheDocument();
    });

    it('버튼 존재 확인', () => {
      // Given & When
      render(<RegistrationSection />);

      // Then
      expect(screen.getByText('팀원 추가')).toBeInTheDocument();
      expect(screen.getByText('참가 신청하기')).toBeInTheDocument();
    });

    it('초기 상태 검증', () => {
      // Given & When
      render(<RegistrationSection />);

      // Then
      expect(screen.getByPlaceholderText(/팀명을 입력하세요/)).toHaveValue('');
    });
  });

  describe('TC-UNIT-010: RegistrationSection 폼 입력 테스트', () => {
    it('팀명 입력 처리', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const teamNameInput = screen.getByPlaceholderText(/팀명을 입력하세요/);

      // When
      await user.type(teamNameInput, '테스트팀');

      // Then
      expect(teamNameInput).toHaveValue('테스트팀');
    });

    it('팀 구성 선택 처리', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      
      // Material-UI Select 컴포넌트를 올바르게 찾기
      const teamSizeSelect = screen.getByText('팀 구성').closest('div')?.querySelector('[role="combobox"]') || 
                            screen.getByText('팀 구성').closest('div')?.querySelector('input');

      // When
      if (teamSizeSelect) {
        // Material-UI Select를 열기 위해 keyDown 이벤트 사용
        fireEvent.keyDown(teamSizeSelect, { key: 'ArrowDown' });
        // 옵션이 나타날 때까지 기다림
        await waitFor(() => {
          expect(screen.getByText('2명')).toBeInTheDocument();
        });
        const option = screen.getByText('2명');
        await user.click(option);
      }

      // Then
      expect(screen.getByText('2명')).toBeInTheDocument();
    });

    it('아이디어 제목 입력 처리', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const ideaTitleInput = screen.getByPlaceholderText(/아이디어의 제목을 입력하세요/);

      // When
      await user.type(ideaTitleInput, 'AI 기반 해커톤 관리 시스템');

      // Then
      expect(ideaTitleInput).toHaveValue('AI 기반 해커톤 관리 시스템');
    });

    it('폼 유효성 검증 - 필수 필드 누락', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const submitButton = screen.getByText('참가 신청하기');

      // When
      await user.click(submitButton);

      // Then
      await waitFor(() => {
        expect(screen.getByText(/팀명을 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/팀 리더 이름을 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/팀 리더 이메일을 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/팀 리더 소속 부서를 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/아이디어 제목을 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/해결하고자 하는 문제를 입력해주세요/)).toBeInTheDocument();
        expect(screen.getByText(/솔루션 접근 방법을 입력해주세요/)).toBeInTheDocument();
      });
    });
  });

  describe('TC-UNIT-011: RegistrationSection 팀 멤버 관리 테스트', () => {
    it('팀 멤버 추가 버튼 동작', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const addMemberButton = screen.getByText('팀원 추가');

      // When
      await user.click(addMemberButton);

      // Then
      // 팀원 추가 버튼은 여전히 1개만 있어야 함
      expect(screen.getAllByText('팀원 추가')).toHaveLength(1);
      // 추가된 팀원 카드가 나타나야 함
      expect(screen.getByText('팀원 1')).toBeInTheDocument();
    });

    it('팀 멤버 삭제 버튼 동작', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const addMemberButton = screen.getByText('팀원 추가');
      await user.click(addMemberButton);

      // When
      const deleteButtons = screen.getAllByTestId('DeleteIcon');
      await user.click(deleteButtons[0]); // 첫 번째 추가된 멤버 삭제

      // Then
      // 팀원 1이 사라져야 함
      expect(screen.queryByText('팀원 1')).not.toBeInTheDocument();
    });

    it('팀 리더 정보 입력 처리', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();
      const leaderNameInput = screen.getByPlaceholderText(/이름을 입력하세요/);
      const leaderEmailInput = screen.getByPlaceholderText(/이메일을 입력하세요/);
      const leaderDepartmentInput = screen.getByPlaceholderText(/부서명을 입력하세요/);

      // When
      await user.type(leaderNameInput, '홍길동');
      await user.type(leaderEmailInput, 'hong@test.com');
      await user.type(leaderDepartmentInput, '개발팀');

      // Then
      expect(leaderNameInput).toHaveValue('홍길동');
      expect(leaderEmailInput).toHaveValue('hong@test.com');
      expect(leaderDepartmentInput).toHaveValue('개발팀');
    });
  });

  describe('TC-UNIT-012: RegistrationSection 폼 제출 테스트', () => {
    it('폼 유효성 검증 실패 시 에러 표시', async () => {
      // Given
      render(<RegistrationSection />);
      const user = userEvent.setup();

      // When
      const submitButton = screen.getByText('참가 신청하기');
      await user.click(submitButton);

      // Then
      await waitFor(() => {
        expect(screen.getByText(/팀명을 입력해주세요/)).toBeInTheDocument();
      });
    });

    it('성공적인 폼 제출 처리', async () => {
      // Given
      const mockResponse = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              department: '개발팀',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING' as const,
      };

      mockedHackathonService.createApplication.mockResolvedValueOnce(mockResponse);

      render(<RegistrationSection />);
      const user = userEvent.setup();

      // 필수 필드 입력
      await user.type(screen.getByPlaceholderText(/팀명을 입력하세요/), '테스트팀');
      await user.type(screen.getByPlaceholderText(/이름을 입력하세요/), '홍길동');
      await user.type(screen.getByPlaceholderText(/이메일을 입력하세요/), 'hong@test.com');
      await user.type(screen.getByPlaceholderText(/부서명을 입력하세요/), '개발팀');
      await user.type(screen.getByPlaceholderText(/아이디어의 제목을 입력하세요/), 'AI 기반 해커톤 관리 시스템');
      await user.type(screen.getByPlaceholderText(/어떤 문제를 해결하고 싶으신가요/), '기존 해커톤 관리의 비효율성');
      await user.type(screen.getByPlaceholderText(/어떤 방식으로 해결하실 계획인가요/), 'AI 기술을 활용한 자동화');

      // When
      const submitButton = screen.getByText('참가 신청하기');
      await user.click(submitButton);

      // Then
      await waitFor(() => {
        expect(mockedHackathonService.createApplication).toHaveBeenCalledWith(
          expect.objectContaining({
            teamName: '테스트팀',
            members: expect.arrayContaining([
              expect.objectContaining({
                name: '홍길동',
                email: 'hong@test.com',
                department: '개발팀',
                isLeader: true,
              }),
            ]),
            ideaTitle: 'AI 기반 해커톤 관리 시스템',
            problemStatement: '기존 해커톤 관리의 비효율성',
            solutionApproach: 'AI 기술을 활용한 자동화',
          })
        );
      });
    });

    it('API 호출 실패 시 에러 처리', async () => {
      // Given
      const errorMessage = '신청서 생성 중 오류가 발생했습니다.';
      mockedHackathonService.createApplication.mockRejectedValueOnce(new Error(errorMessage));

      render(<RegistrationSection />);
      const user = userEvent.setup();

      // 필수 필드 입력
      await user.type(screen.getByPlaceholderText(/팀명을 입력하세요/), '테스트팀');
      await user.type(screen.getByPlaceholderText(/이름을 입력하세요/), '홍길동');
      await user.type(screen.getByPlaceholderText(/이메일을 입력하세요/), 'hong@test.com');
      await user.type(screen.getByPlaceholderText(/부서명을 입력하세요/), '개발팀');
      await user.type(screen.getByPlaceholderText(/아이디어의 제목을 입력하세요/), 'AI 기반 해커톤 관리 시스템');
      await user.type(screen.getByPlaceholderText(/어떤 문제를 해결하고 싶으신가요/), '기존 해커톤 관리의 비효율성');
      await user.type(screen.getByPlaceholderText(/어떤 방식으로 해결하실 계획인가요/), 'AI 기술을 활용한 자동화');

      // When
      const submitButton = screen.getByText('참가 신청하기');
      await user.click(submitButton);

      // Then
      await waitFor(() => {
        expect(screen.getByText(errorMessage)).toBeInTheDocument();
      });
    });
  });
}); 


================================================
FILE: frontend/src/model/types.ts
================================================
// Common response type
export interface CommonResponse<T = any> {
  successOrNot: boolean;
  statusCode: number;
  data: T;
  message?: string;
}

// Hackathon application types
export interface TeamMember {
  id?: number;
  name: string;
  email: string;
  phone?: string;
  role?: string;
  department?: string;
  position?: string;
  isLeader?: boolean;
}

export interface Team {
  id?: number;
  teamName: string;
  teamSize?: string;
  teamDescription?: string;
  members?: TeamMember[];
}

export interface HackathonApplication {
  id?: number;
  team: Team;
  ideaTitle?: string;
  ideaDescription?: string;
  problemStatement?: string;
  solutionApproach?: string;
  techStack?: string;
  status?: 'PENDING' | 'APPROVED' | 'REJECTED';
  firstCreateDatetime?: string;
  lastUpdateDatetime?: string;
}

// API request/response types
export interface CreateApplicationRequest {
  teamName: string;
  teamSize?: string;
  teamDescription?: string;
  ideaTitle?: string;
  ideaDescription?: string;
  problemStatement?: string;
  solutionApproach?: string;
  techStack?: string;
  members: TeamMember[];
}

export interface CreateApplicationResponse extends CommonResponse<HackathonApplication> {}

export interface GetApplicationRequest {
  teamName?: string;
  memberName?: string;
}

export interface GetApplicationResponse extends CommonResponse<HackathonApplication[]> {}

export interface UpdateApplicationRequest extends CreateApplicationRequest {}

export interface UpdateApplicationResponse extends CommonResponse<HackathonApplication> {}

export interface DeleteApplicationResponse extends CommonResponse<void> {}

// Navigation types
export type NavigationItem = 'intro' | 'participation' | 'registration' | 'confirmation';

// Form types
export interface TeamFormData {
  teamName: string;
  teamSize?: string;
  teamDescription?: string;
  members: TeamMember[];
}

export interface IdeaFormData {
  ideaTitle: string;
  ideaDescription: string;
  problemStatement: string;
  solutionApproach: string;
  techStack?: string;
}

export interface ApplicationFormData extends TeamFormData, IdeaFormData {} 


================================================
FILE: frontend/src/services/HackathonService.ts
================================================
import { axiosInstance } from '../api/axios';
import type {
  CreateApplicationRequest,
  GetApplicationRequest,
  HackathonApplication,
} from '../model/types';

export class HackathonService {
  static async createApplication(data: CreateApplicationRequest): Promise<HackathonApplication> {
    const response = await axiosInstance.post('/api/hackathon/v1/applications', data);
    return response.data;
  }

  static async getApplications(params?: GetApplicationRequest): Promise<HackathonApplication[]> {
    try {
      const response = await axiosInstance.get('/api/hackathon/v1/applications', { 
        params,
        timeout: 10000,
      });
      return response.data;
    } catch (error: any) {
      console.error('API Error:', error);
      if (error.response?.status === 400) {
        throw new Error('검색 조건이 올바르지 않습니다.');
      } else if (error.response?.status === 404) {
        throw new Error('해당 정보를 찾을 수 없습니다.');
      } else {
        throw new Error('조회 중 오류가 발생했습니다.');
      }
    }
  }

  static async getApplication(id: number): Promise<HackathonApplication> {
    const response = await axiosInstance.get(`/api/hackathon/v1/applications/${id}`);
    return response.data;
  }

  static async updateApplication(id: number, data: CreateApplicationRequest): Promise<HackathonApplication> {
    const response = await axiosInstance.put(`/api/hackathon/v1/applications/${id}`, data);
    return response.data;
  }

  static async deleteApplication(id: number): Promise<void> {
    await axiosInstance.delete(`/api/hackathon/v1/applications/${id}`);
  }
} 


================================================
FILE: frontend/src/services/__tests__/HackathonService.test.ts
================================================
[Binary file]


================================================
FILE: frontend/src/stores/HackathonStore.ts
================================================
import { create } from 'zustand';
import type { HackathonApplication, TeamMember, Team } from '../model/types';
import { HackathonService } from '../services/HackathonService';

interface HackathonState {
  applications: HackathonApplication[];
  currentApplication: HackathonApplication | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  setApplications: (applications: HackathonApplication[]) => void;
  setCurrentApplication: (application: HackathonApplication | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  
  // API Actions
  createApplication: (data: any) => Promise<void>;
  getApplications: (params?: any) => Promise<void>;
  getApplication: (id: number) => Promise<void>;
  updateApplication: (id: number, data: any) => Promise<void>;
  deleteApplication: (id: number) => Promise<void>;
  
  // Team management
  addTeamMember: (member: TeamMember) => void;
  removeTeamMember: (index: number) => void;
  updateTeamMember: (index: number, member: TeamMember) => void;
  
  // Form management
  updateTeamInfo: (teamInfo: Partial<Team>) => void;
  updateIdeaInfo: (ideaInfo: Partial<{ ideaTitle?: string; ideaDescription?: string }>) => void;
  
  // Reset
  reset: () => void;
}

const initialState = {
  applications: [],
  currentApplication: null,
  isLoading: false,
  error: null,
};

export const useHackathonStore = create<HackathonState>((set, get) => ({
  ...initialState,
  
  setApplications: (applications) => set({ applications }),
  setCurrentApplication: (application) => set({ currentApplication: application }),
  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),
  
  createApplication: async (data) => {
    try {
      set({ isLoading: true, error: null });
      const application = await HackathonService.createApplication(data);
      set({ currentApplication: application, isLoading: false });
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error', isLoading: false });
    }
  },
  
  getApplications: async (params) => {
    try {
      set({ isLoading: true, error: null });
      const applications = await HackathonService.getApplications(params);
      set({ applications, isLoading: false });
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error', isLoading: false });
    }
  },
  
  getApplication: async (id) => {
    try {
      set({ isLoading: true, error: null });
      const application = await HackathonService.getApplication(id);
      set({ currentApplication: application, isLoading: false });
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error', isLoading: false });
    }
  },
  
  updateApplication: async (id, data) => {
    try {
      set({ isLoading: true, error: null });
      const application = await HackathonService.updateApplication(id, data);
      set({ currentApplication: application, isLoading: false });
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error', isLoading: false });
    }
  },
  
  deleteApplication: async (id) => {
    try {
      set({ isLoading: true, error: null });
      await HackathonService.deleteApplication(id);
      set({ currentApplication: null, isLoading: false });
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Unknown error', isLoading: false });
    }
  },
  
  addTeamMember: (member) => {
    const { currentApplication } = get();
    if (currentApplication && currentApplication.team) {
      const updatedMembers = [...(currentApplication.team.members || []), member];
      set({
        currentApplication: {
          ...currentApplication,
          team: {
            ...currentApplication.team,
            members: updatedMembers,
          },
        },
      });
    }
  },
  
  removeTeamMember: (index) => {
    const { currentApplication } = get();
    if (currentApplication && currentApplication.team) {
      const updatedMembers = (currentApplication.team.members || []).filter((_, i) => i !== index);
      set({
        currentApplication: {
          ...currentApplication,
          team: {
            ...currentApplication.team,
            members: updatedMembers,
          },
        },
      });
    }
  },
  
  updateTeamMember: (index, member) => {
    const { currentApplication } = get();
    if (currentApplication && currentApplication.team) {
      const updatedMembers = [...(currentApplication.team.members || [])];
      updatedMembers[index] = member;
      set({
        currentApplication: {
          ...currentApplication,
          team: {
            ...currentApplication.team,
            members: updatedMembers,
          },
        },
      });
    }
  },
  
  updateTeamInfo: (teamInfo) => {
    const { currentApplication } = get();
    if (currentApplication) {
      set({
        currentApplication: {
          ...currentApplication,
          team: {
            ...currentApplication.team,
            ...teamInfo,
          },
        },
      });
    }
  },
  
  updateIdeaInfo: (ideaInfo) => {
    const { currentApplication } = get();
    if (currentApplication) {
      set({
        currentApplication: {
          ...currentApplication,
          ...ideaInfo,
        },
      });
    }
  },
  
  reset: () => set(initialState),
})); 


================================================
FILE: frontend/src/stores/__tests__/HackathonStore.test.ts
================================================
import { renderHook, act } from '@testing-library/react';
import { useHackathonStore } from '../HackathonStore';
import { HackathonService } from '../../services/HackathonService';
import type { HackathonApplication, TeamMember, Team } from '../../model/types';

// HackathonService 모킹
jest.mock('../../services/HackathonService', () => ({
  HackathonService: {
    createApplication: jest.fn(),
    getApplications: jest.fn(),
    getApplication: jest.fn(),
    updateApplication: jest.fn(),
    deleteApplication: jest.fn(),
  },
}));

const mockedHackathonService = HackathonService as jest.Mocked<typeof HackathonService>;

describe('HackathonStore', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // 스토어 초기화
    const { result } = renderHook(() => useHackathonStore());
    act(() => {
      result.current.reset();
    });
  });

  describe('TC-UNIT-006: 상태 관리 테스트', () => {
    it('초기 상태 설정', () => {
      // Given & When
      const { result } = renderHook(() => useHackathonStore());

      // Then
      expect(result.current.applications).toEqual([]);
      expect(result.current.currentApplication).toBeNull();
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('로딩 상태 변경', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());

      // When
      act(() => {
        result.current.setLoading(true);
      });

      // Then
      expect(result.current.isLoading).toBe(true);

      // When
      act(() => {
        result.current.setLoading(false);
      });

      // Then
      expect(result.current.isLoading).toBe(false);
    });

    it('에러 상태 설정', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const errorMessage = '테스트 에러 메시지';

      // When
      act(() => {
        result.current.setError(errorMessage);
      });

      // Then
      expect(result.current.error).toBe(errorMessage);

      // When
      act(() => {
        result.current.setError(null);
      });

      // Then
      expect(result.current.error).toBeNull();
    });

    it('애플리케이션 목록 설정', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplications: HackathonApplication[] = [
        {
          id: 1,
          team: {
            id: 1,
            teamName: '테스트팀1',
            members: [
              {
                id: 1,
                name: '홍길동',
                email: 'hong@test.com',
                role: '팀장',
                isLeader: true,
              },
            ],
          },
          ideaTitle: 'AI 기반 해커톤 관리 시스템',
          status: 'PENDING',
        },
        {
          id: 2,
          team: {
            id: 2,
            teamName: '테스트팀2',
            members: [
              {
                id: 2,
                name: '김철수',
                email: 'kim@test.com',
                role: '팀장',
                isLeader: true,
              },
            ],
          },
          ideaTitle: '블록체인 기반 투표 시스템',
          status: 'APPROVED',
        },
      ];

      // When
      act(() => {
        result.current.setApplications(mockApplications);
      });

      // Then
      expect(result.current.applications).toEqual(mockApplications);
    });

    it('현재 애플리케이션 설정', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      // When
      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      // Then
      expect(result.current.currentApplication).toEqual(mockApplication);

      // When
      act(() => {
        result.current.setCurrentApplication(null);
      });

      // Then
      expect(result.current.currentApplication).toBeNull();
    });
  });

  describe('TC-UNIT-007: API 액션 테스트', () => {
    it('createApplication 액션 성공', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };
      const createData = {
        teamName: '테스트팀',
        memberName: '홍길동',
        email: 'hong@test.com',
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
      };

      mockedHackathonService.createApplication.mockResolvedValueOnce(mockApplication);

      // When
      await act(async () => {
        await result.current.createApplication(createData);
      });

      // Then
      expect(mockedHackathonService.createApplication).toHaveBeenCalledWith(createData);
      expect(result.current.currentApplication).toEqual(mockApplication);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('createApplication 액션 실패', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const errorMessage = '신청서 생성 실패';
      const createData = {
        teamName: '테스트팀',
        memberName: '홍길동',
        email: 'hong@test.com',
      };

      mockedHackathonService.createApplication.mockRejectedValueOnce(new Error(errorMessage));

      // When
      await act(async () => {
        await result.current.createApplication(createData);
      });

      // Then
      expect(mockedHackathonService.createApplication).toHaveBeenCalledWith(createData);
      expect(result.current.currentApplication).toBeNull();
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBe(errorMessage);
    });

    it('getApplications 액션 성공', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplications: HackathonApplication[] = [
        {
          id: 1,
          team: {
            id: 1,
            teamName: '테스트팀1',
            members: [
              {
                id: 1,
                name: '홍길동',
                email: 'hong@test.com',
                role: '팀장',
                isLeader: true,
              },
            ],
          },
          ideaTitle: 'AI 기반 해커톤 관리 시스템',
          status: 'PENDING',
        },
      ];
      const searchParams = { teamName: '테스트팀1' };

      mockedHackathonService.getApplications.mockResolvedValueOnce(mockApplications);

      // When
      await act(async () => {
        await result.current.getApplications(searchParams);
      });

      // Then
      expect(mockedHackathonService.getApplications).toHaveBeenCalledWith(searchParams);
      expect(result.current.applications).toEqual(mockApplications);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('getApplications 액션 실패', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const errorMessage = '신청서 조회 실패';

      mockedHackathonService.getApplications.mockRejectedValueOnce(new Error(errorMessage));

      // When
      await act(async () => {
        await result.current.getApplications();
      });

      // Then
      expect(mockedHackathonService.getApplications).toHaveBeenCalledWith(undefined);
      expect(result.current.applications).toEqual([]);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBe(errorMessage);
    });

    it('getApplication 액션 성공', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      mockedHackathonService.getApplication.mockResolvedValueOnce(mockApplication);

      // When
      await act(async () => {
        await result.current.getApplication(1);
      });

      // Then
      expect(mockedHackathonService.getApplication).toHaveBeenCalledWith(1);
      expect(result.current.currentApplication).toEqual(mockApplication);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('updateApplication 액션 성공', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockUpdatedApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '수정된팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: '수정된 아이디어',
        status: 'PENDING',
      };
      const updateData = {
        teamName: '수정된팀',
        memberName: '홍길동',
        email: 'hong@test.com',
        ideaTitle: '수정된 아이디어',
      };

      mockedHackathonService.updateApplication.mockResolvedValueOnce(mockUpdatedApplication);

      // When
      await act(async () => {
        await result.current.updateApplication(1, updateData);
      });

      // Then
      expect(mockedHackathonService.updateApplication).toHaveBeenCalledWith(1, updateData);
      expect(result.current.currentApplication).toEqual(mockUpdatedApplication);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('deleteApplication 액션 성공', async () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      // 현재 애플리케이션 설정
      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      mockedHackathonService.deleteApplication.mockResolvedValueOnce();

      // When
      await act(async () => {
        await result.current.deleteApplication(1);
      });

      // Then
      expect(mockedHackathonService.deleteApplication).toHaveBeenCalledWith(1);
      expect(result.current.currentApplication).toBeNull();
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });
  });

  describe('TC-UNIT-008: 팀 관리 테스트', () => {
    it('팀 멤버 추가', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      const newMember: TeamMember = {
        name: '김철수',
        email: 'kim@test.com',
        phone: '010-2345-6789',
        role: '개발자',
        department: '개발팀',
        position: '개발자',
        isLeader: false,
      };

      // When
      act(() => {
        result.current.addTeamMember(newMember);
      });

      // Then
      expect(result.current.currentApplication?.team.members).toHaveLength(2);
      expect(result.current.currentApplication?.team.members?.[1]).toEqual(newMember);
    });

    it('팀 멤버 삭제', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
            {
              id: 2,
              name: '김철수',
              email: 'kim@test.com',
              role: '개발자',
              isLeader: false,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      // When
      act(() => {
        result.current.removeTeamMember(1); // 두 번째 멤버 삭제
      });

      // Then
      expect(result.current.currentApplication?.team.members).toHaveLength(1);
      expect(result.current.currentApplication?.team.members?.[0].name).toBe('홍길동');
    });

    it('팀 멤버 수정', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      const updatedMember: TeamMember = {
        name: '홍길동',
        email: 'hong.updated@test.com',
        phone: '010-9999-9999',
        role: '수석개발자',
        department: '개발팀',
        position: '수석개발자',
        isLeader: true,
      };

      // When
      act(() => {
        result.current.updateTeamMember(0, updatedMember);
      });

      // Then
      expect(result.current.currentApplication?.team.members?.[0]).toEqual(updatedMember);
    });

    it('팀 정보 업데이트', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        status: 'PENDING',
      };

      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      const updatedTeamInfo: Partial<Team> = {
        teamName: '수정된팀명',
      };

      // When
      act(() => {
        result.current.updateTeamInfo(updatedTeamInfo);
      });

      // Then
      expect(result.current.currentApplication?.team.teamName).toBe('수정된팀명');
    });

    it('아이디어 정보 업데이트', () => {
      // Given
      const { result } = renderHook(() => useHackathonStore());
      const mockApplication: HackathonApplication = {
        id: 1,
        team: {
          id: 1,
          teamName: '테스트팀',
          members: [
            {
              id: 1,
              name: '홍길동',
              email: 'hong@test.com',
              role: '팀장',
              isLeader: true,
            },
          ],
        },
        ideaTitle: 'AI 기반 해커톤 관리 시스템',
        ideaDescription: '기존 아이디어 설명',
        status: 'PENDING',
      };

      act(() => {
        result.current.setCurrentApplication(mockApplication);
      });

      const updatedIdeaInfo = {
        ideaTitle: '수정된 아이디어 제목',
        ideaDescription: '수정된 아이디어 설명',
      };

      // When
      act(() => {
        result.current.updateIdeaInfo(updatedIdeaInfo);
      });

      // Then
      expect(result.current.currentApplication?.ideaTitle).toBe('수정된 아이디어 제목');
      expect(result.current.currentApplication?.ideaDescription).toBe('수정된 아이디어 설명');
    });
  });
}); 


================================================
FILE: frontend/src/theme/index.ts
================================================
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  palette: {
    primary: {
      main: '#9810fa', // Electric Violet
      light: '#c084fc', // purple-400
      dark: '#6b21a8', // purple-800
    },
    secondary: {
      main: '#8b5cf6', // violet-500
    },
    background: {
      default: '#ffffff',
      paper: '#f8fafc',
    },
    text: {
      primary: '#101828', // azure/11
      secondary: '#4a5565', // azure/34
    },
    grey: {
      50: '#f8fafc',
      100: '#f1f5f9',
      200: '#e2e8f0',
      300: '#cbd5e1',
      400: '#94a3b8',
      500: '#64748b',
      600: '#475569',
      700: '#334155',
      800: '#1e293b',
      900: '#0f172a',
    },
    // 슬레이트 색상 추가
    slate: {
      50: '#f8fafc',
      100: '#f1f5f9',
      200: '#e2e8f0',
      300: '#cbd5e1',
      400: '#94a3b8',
      500: '#64748b',
      600: '#475569',
      700: '#334155',
      800: '#1e293b',
      900: '#0f172a',
    },
    // 퍼플 색상 추가
    purple: {
      50: '#faf5ff',
      100: '#f3e8ff',
      200: '#e9d5ff',
      300: '#d8b4fe',
      400: '#c084fc',
      500: '#a855f7',
      600: '#9333ea',
      700: '#7c3aed',
      800: '#6b21a8',
      900: '#581c87',
    },
    // 커스텀 색상 추가
    custom: {
      azure: {
        11: '#101828',
        34: '#4a5565',
        46: '#6a7282',
      },
      grey: {
        4: '#0a0a0a',
        48: '#717182',
        91: '#e5e7eb',
        96: '#f3f3f5',
        97: '#eff6ff',
        98: '#f9fafb',
      },
      violet: {
        52: '#9810fa',
      },
    },
  },
  typography: {
    fontFamily: '"Apple SD Gothic Neo", "SF Pro Text", sans-serif',
    h1: {
      fontSize: '63px',
      fontWeight: 700,
      lineHeight: '78.75px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    h2: {
      fontSize: '42px',
      fontWeight: 700,
      lineHeight: '42px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    h3: {
      fontSize: '21px',
      fontWeight: 600,
      lineHeight: '28px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    h4: {
      fontSize: '21px',
      fontWeight: 400,
      lineHeight: '28px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    body1: {
      fontSize: '17.5px',
      fontWeight: 400,
      lineHeight: '24.5px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    body2: {
      fontSize: '14px',
      fontWeight: 400,
      lineHeight: '21px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    caption: {
      fontSize: '12.3px',
      fontWeight: 400,
      lineHeight: '17.5px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    label: {
      fontSize: '12.3px',
      fontWeight: 500,
      lineHeight: '12.25px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
    input: {
      fontSize: '12.3px',
      fontWeight: 400,
      lineHeight: '100%',
      fontFamily: '"SF Pro Text", sans-serif',
    },
    button: {
      fontSize: '15.8px',
      fontWeight: 500,
      lineHeight: '24.5px',
      fontFamily: '"Apple SD Gothic Neo", sans-serif',
    },
  },
  spacing: (factor: number) => `${factor * 7}px`,
  shape: {
    borderRadius: 8.75,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: '50px',
          textTransform: 'none',
          fontWeight: 500,
          fontFamily: '"Apple SD Gothic Neo", sans-serif',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: '6.75px',
            backgroundColor: '#f3f3f5',
            height: '31.5px',
            '& fieldset': {
              border: 'none',
            },
            '& input': {
              fontSize: '12.3px',
              padding: '8.5px 11.5px',
              color: '#717182',
              fontFamily: '"SF Pro Text", sans-serif',
            },
            '& textarea': {
              fontSize: '12.3px',
              padding: '0px 0px',
              color: '#717182',
              fontFamily: '"Apple SD Gothic Neo", sans-serif',
              lineHeight: '17.5px',
            },
            '&:hover': {
              backgroundColor: '#e2e8f0',
            },
            '&.Mui-focused': {
              backgroundColor: '#ffffff',
              border: '1px solid #9810fa',
            },
          },
          '& .MuiInputLabel-root': {
            fontSize: '12.3px',
            color: '#64748b',
          },
          '& .MuiSelect-select': {
            fontSize: '12.3px',
            padding: '8px 11.5px',
            color: '#717182',
            fontFamily: '"Apple SD Gothic Neo", sans-serif',
            lineHeight: '17.5px',
            textAlign: 'left',
          },
          '& .MuiSelect-icon': {
            color: '#717182',
            opacity: 0.5,
          },
          '&.multiline': {
            '& .MuiOutlinedInput-root': {
              height: 'auto',
              minHeight: '42px',
            },
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundColor: '#ffffff',
          borderRadius: '12.75px',
          border: '1px solid rgba(0,0,0,0.01)',
          boxShadow: '0px 10px 15px -3px rgba(0,0,0,0.1), 0px 4px 6px -4px rgba(0,0,0,0.1)',
          transition: 'box-shadow 0.2s ease',
          '&:hover': {
            boxShadow: '0px 20px 25px -5px rgba(0,0,0,0.1), 0px 10px 10px -5px rgba(0,0,0,0.04)',
          },
        },
      },
    },
    MuiTypography: {
      styleOverrides: {
        root: {
          fontFamily: '"Apple SD Gothic Neo", sans-serif',
        },
      },
    },
  },
});

// 공통 스타일 상수
export const commonStyles = {
  // 컨테이너 스타일
  container: {
    padding: '70px 568px',
    minHeight: 1200,
    background: 'linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%)',
  },
  contentContainer: {
    maxWidth: 784,
    margin: '0 auto',
    padding: '0 21px',
  },
  
  // 헤더 스타일
  headerSection: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '21px',
    marginBottom: '42px',
  },
  
  // 카드 스타일
  cardHeader: {
    padding: '21px 21px 5.25px 21px',
    borderBottom: 'none',
  },
  cardContent: {
    padding: '0 21px 21px 21px',
    display: 'flex',
    flexDirection: 'column',
    gap: '20.25px',
  },
  
  // 폼 스타일
  formRow: {
    display: 'flex',
    gap: '21px',
    width: '100%',
    '@media (max-width: 768px)': {
      flexDirection: 'column',
    },
  },
  formField: {
    marginBottom: '0',
    '&.half-width': {
      flex: '0 0 calc(50% - 10.5px)',
    },
  },
  
  // 팀원 카드 스타일
  teamMemberCard: {
    backgroundColor: '#ffffff',
    borderRadius: '8.75px',
    border: '1px solid #e5e7eb',
    padding: '22px',
    marginBottom: '14px',
    boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.1)',
    transition: 'box-shadow 0.2s ease',
    '&:hover': {
      boxShadow: '0px 4px 6px rgba(0, 0, 0, 0.1)',
    },
  },
  
  // 버튼 스타일
  primaryButton: {
    backgroundColor: '#9810fa',
    color: '#ffffff',
    fontSize: '15.8px',
    fontWeight: 500,
    padding: '14px 42px',
    borderRadius: '50px',
    textTransform: 'none',
    lineHeight: '24.5px',
    fontFamily: '"Apple SD Gothic Neo", sans-serif',
    minHeight: '31.5px',
    '&:hover': {
      backgroundColor: '#59168b',
    },
  },
  secondaryButton: {
    backgroundColor: '#ffffff',
    color: '#0a0a0a',
    fontSize: '12.3px',
    fontWeight: 500,
    padding: '1px 9.75px',
    borderRadius: '6.75px',
    border: '1px solid rgba(0,0,0,0.01)',
    minHeight: '28px',
    textTransform: 'none',
    lineHeight: '17.5px',
    fontFamily: '"Apple SD Gothic Neo", sans-serif',
    '&:hover': {
      backgroundColor: '#f9fafb',
    },
  },
  
  // 성공 화면 스타일
  successContainer: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    textAlign: 'center',
    padding: '80px 0',
  },
};

// 공통 스타일 유틸리티 함수
export const createCommonStyle = (styleName: keyof typeof commonStyles) => {
  return () => commonStyles[styleName];
};

// 자주 사용되는 스타일 조합
export const styleUtils = {
  // 섹션 제목 스타일
  sectionTitle: {
    fontSize: '42px',
    fontWeight: 700,
    color: '#101828',
    textAlign: 'center',
    lineHeight: '42px',
  },
  
  // 섹션 부제목 스타일
  sectionSubtitle: {
    fontSize: '17.5px',
    color: '#4a5565',
    textAlign: 'center',
    maxWidth: '588px',
    lineHeight: '24.5px',
  },
  
  // 카드 제목 스타일
  cardTitle: {
    fontSize: '21px',
    fontWeight: 400,
    color: '#101828',
    lineHeight: '28px',
  },
  
  // 필드 라벨 스타일
  fieldLabel: {
    fontSize: '12.3px',
    fontWeight: 500,
    color: '#0a0a0a',
    marginBottom: '7px',
    lineHeight: '12.25px',
  },
  
  // 팀원 제목 스타일
  teamMemberTitle: {
    fontSize: '14px',
    fontWeight: 600,
    color: '#101828',
    lineHeight: '21px',
  },
  
  // 성공 아이콘 스타일
  successIcon: {
    fontSize: '80px',
    color: '#10b981',
    marginBottom: '24px',
  },
  
  // 성공 제목 스타일
  successTitle: {
    fontSize: '36px',
    fontWeight: 700,
    color: '#101828',
    marginBottom: '16px',
  },
  
  // 성공 메시지 스타일
  successMessage: {
    fontSize: '20px',
    color: '#6b7280',
    marginBottom: '32px',
    lineHeight: '28px',
  },
  
  // 제출 노트 스타일
  submitNote: {
    fontSize: '12.3px',
    color: '#6a7282',
    textAlign: 'center',
    lineHeight: '17.5px',
    marginTop: '28px',
  },
}; 

